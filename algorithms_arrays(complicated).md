## ЗАДАЧА 1: Поворот изображения на 90 градусов

Дана матрица изображения размером n x n. Необходимо повернуть изображение на 90 градусов по часовой стрелке.

Нужно повернуть изображение на месте (in-place). Это означает, что нужно изменить входную 2D матрицу непосредственно. НЕ выделяйте дополнительную 2D матрицу и не проводите поворот.

Пример 1:
![image](./imgs/mat1.jpg)

```js
**Вход:** matrix = [[1,2,3],[4,5,6],[7,8,9]]
**Выход:** [[7,4,1],[8,5,2],[9,6,3]]
```

Пример 2:
![image](./imgs/mat2.jpg)

```js
**Вход:** matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
**Выход:** [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

Ограничения:

```js
(n == matrix.length) == matrix[i].length;
1 <= n <= 20 - 1000 <= matrix[i][j] <= 1000;
```

Алгоритм 1
Для решения этой задачи мы можем разделить проблему на два этапа:

Транспонирование матрицы.
Обращение порядка элементов в каждой строке.
Транспонирование матрицы означает замену строк на столбцы и столбцов на строки. Мы можем достичь этого, обменяв элементы matrix[i][j] и matrix[j][i] для каждой пары индексов (i, j) только для тех случаев, когда i < j.

После выполнения транспонирования нам нужно поменять порядок элементов в каждой строке, чтобы получить поворот на 90 градусов. Мы можем достичь этого, поменяв местами элементы matrix[i][j] и matrix[i][n-j-1], где n - размерность матрицы, для каждой пары индексов (i, j).

Используя эти два этапа, мы можем повернуть матрицу на 90 градусов по часовой стрелке. Оба этапа будут выполняться "на месте", без выделения дополнительной памяти или создания новой матрицы.

На практике это означает, что мы будем использовать две вложенные цикла for для обращения порядка элементов в каждой строке, а затем еще два вложенных цикла for для транспонирования матрицы, меняя местами элементы matrix[i][j] и matrix[j][i] только для тех случаев, когда i < j.

```js
const rotateImage = (matrix) => {
  const n = matrix.length;

  // Транспонирование матрицы
  for (let i = 0; i < n; i++) {
    for (let j = i; j < n; j++) {
      const temp = matrix[i][j];
      matrix[i][j] = matrix[j][i];
      matrix[j][i] = temp;
    }
  }

  // Переворачивание столбцов матрицы
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < Math.floor(n / 2); j++) {
      const temp = matrix[i][j];
      matrix[i][j] = matrix[i][n - 1 - j];
      matrix[i][n - 1 - j] = temp;
    }
  }

  return matrix;
};
```

## ЗАДАЧА 2: Минимальный путь в сетке

Дана сетка m x n, заполненная неотрицательными числами. Найдите путь от верхнего левого угла до нижнего правого угла, который минимизирует сумму всех чисел вдоль этого пути.

Примечание: Вы можете двигаться только вниз или вправо в любой момент времени.

Пример 1:
![image](./imgs/minpath.jpg)

```js
**Ввод:** сетка = [[1,3,1],[1,5,1],[4,2,1]]
**Вывод:** 7
**Объяснение:** Путь 1 → 3 → 1 → 1 → 1 минимизирует сумму.
```

Пример 2:

```js
**Ввод:** сетка = [[1,2,3],[4,5,6]]
**Вывод:** 12
```

Ограничения:

```js
m == длина сетки
n == длина сетки[i]
1 <= m, n <= 200
0 <= сетка[i][j] <= 200
```

Алгоритм 1
Для решения данной задачи можно использовать динамическое программирование.

Создадим двумерный массив dp размером m x n, где dp[i][j] будет представлять минимальную сумму чисел на пути от верхнего левого угла до клетки (i, j).

Изначально заполним первый столбец и первую строку массива dp. Для первого столбца значения dp[i][0] будут равны сумме чисел на пути от верхнего левого угла до клетки (i, 0). Аналогично, для первой строки значения dp[0][j] будут равны сумме чисел на пути от верхнего левого угла до клетки (0, j).

Затем воспользуемся следующим рекуррентным соотношением для заполнения остальных клеток массива dp: dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]), где grid[i][j] - число в клетке (i, j).

Таким образом, после заполнения массива dp последнее значение dp[m-1][n-1] будет представлять минимальную сумму чисел на пути от верхнего левого угла до нижнего правого угла.

Возвращаем dp[m-1][n-1] в качестве ответа.

```js
function minPathSum(grid) {
  const m = grid.length;
  const n = grid[0].length;

  // Создаем двумерный массив dp с размерами m x n
  const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));

  // Заполняем первую строку dp суммами значений в grid
  for (let j = 0; j < n; j++) {
    if (j === 0) {
      dp[0][j] = grid[0][j];
    } else {
      dp[0][j] = grid[0][j] + dp[0][j - 1];
    }
  }

  // Заполняем первый столбец dp суммами значений в grid
  for (let i = 0; i < m; i++) {
    if (i === 0) {
      dp[i][0] = grid[i][0];
    } else {
      dp[i][0] = grid[i][0] + dp[i - 1][0];
    }
  }

  // Заполняем остальные значения dp
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);
    }
  }

  // Возвращаем значение в нижем правом углу dp
  return dp[m - 1][n - 1];
}

// Примеры тестов
console.log(
  minPathSum([
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1],
  ])
); // 7
console.log(
  minPathSum([
    [1, 2, 3],
    [4, 5, 6],
  ])
); // 12
```

## ЗАДАЧА 3: Проверка доски Судоку

Определить, является ли доска Судоку размером 9 x 9 действительной. Только заполненные ячейки должны быть проверены в соответствии со следующими правилами:

Каждая строка должна содержать цифры от 1 до 9 без повторений.
Каждый столбец должен содержать цифры от 1 до 9 без повторений.
Каждый из девяти 3 x 3 подквадратов сетки должен содержать цифры от 1 до 9 без повторений.
Примечание:

Доска Судоку (частично заполненная) может быть действительной, но не обязательно разрешимой.
Только заполненные ячейки должны быть проверены в соответствии с упомянутыми правилами.
Пример 1:

![image](./imgs/sudoku.png)

```js
**Вход:** board =
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]

**Выход:** true
```

Пример 2:

```js
**Вход**: board =
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]

**Выход:** false
**Объяснение:** То же самое, что и в Примере 1, кроме того, что **5** в верхнем левом углу заменено на **8**. Поскольку в верхнем левом подквадрате 3x3 две 8, он недействителен.
```

Ограничения:

```js
board.length == 9
board[i].length == 9
board[i][j] является цифрой 1-9 или '.'.
```

Алгоритм 1
Для решения этой задачи нам необходимо проверить, является ли заданная доска Судоку действительной.

Правила Судоку гласят:

Каждая строка должна содержать только цифры от 1 до 9 без повторений.
Каждый столбец должен содержать только цифры от 1 до 9 без повторений.
Каждый из девяти '3 x 3' подквадратов должен содержать только цифры от 1 до 9 без повторений.
Для проверки каждого из этих правил мы можем использовать три набора соответствующих флагов.

Первый набор флагов будет отслеживать наличие числа в каждой строке. Каждый раз, когда мы встречаем число в строке, мы проверяем, появлялось ли это число ранее в текущей строке. Если да, то доска является недействительной. Если нет, то мы устанавливаем соответствующий флаг для этого числа.

Второй набор флагов будет отслеживать наличие числа в каждом столбце. Каждый раз, когда мы встречаем число в столбце, мы проверяем, появлялось ли это число ранее в текущем столбце. Если да, то доска является недействительной. Если нет, то мы устанавливаем соответствующий флаг для этого числа.

Третий набор флагов будет отслеживать наличие числа в каждом подквадрате 3x3. Мы будем использовать блок кода i//3 \* 3 + j//3, чтобы определить индекс текущего подквадрата 3x3. Каждый раз, когда мы встречаем число в подквадрате 3x3, мы проверяем, появлялось ли это число ранее в текущем подквадрате. Если да, то доска является недействительной. Если нет, то мы устанавливаем соответствующий флаг для этого числа.

В конце проверки всех чисел в доске мы проверяем все флаги. Если флаг для какого-либо числа не был установлен, то доска является недействительной. Если все флаги были установлены, то доска является действительной.

Таким образом, мы можем написать алгоритм, который будет выполнять описанную выше проверку для каждой строки, столбца и подквадрата 3x3 доски Судоку.

```js
const isValidSudoku = (board) => {
  // Проверка строк
  for (let i = 0; i < 9; i++) {
    const rowSet = new Set();
    for (let j = 0; j < 9; j++) {
      if (board[i][j] !== ".") {
        if (rowSet.has(board[i][j])) {
          return false;
        }
        rowSet.add(board[i][j]);
      }
    }
  }

  // Проверка столбцов
  for (let j = 0; j < 9; j++) {
    const colSet = new Set();
    for (let i = 0; i < 9; i++) {
      if (board[i][j] !== ".") {
        if (colSet.has(board[i][j])) {
          return false;
        }
        colSet.add(board[i][j]);
      }
    }
  }

  // Проверка подквадратов 3x3
  for (let k = 0; k < 9; k++) {
    const subgridSet = new Set();
    for (let i = Math.floor(k / 3) * 3; i < Math.floor(k / 3) * 3 + 3; i++) {
      for (let j = (k % 3) * 3; j < (k % 3) * 3 + 3; j++) {
        if (board[i][j] !== ".") {
          if (subgridSet.has(board[i][j])) {
            return false;
          }
          subgridSet.add(board[i][j]);
        }
      }
    }
  }

  return true;
};
```
