// ЗАДАЧА 1: Вычисление числа Фибоначчи
// Реализуйте функцию fibonacci(n), которая возвращает n-ное число Фибоначчи.

// Числа Фибоначчи определяются следующим образом: F(0) = 0, F(1) = 1, и для всех n больше 1, F(n) = F(n-1) + F(n-2).

// Функция:

// /\*_
// _ @param {number} n - Неотрицательное целое число, для которого нужно вычислить число Фибоначчи.
// _ @return {number} - n-ное число Фибоначчи.
// _/
// function fibonacci(n) {
// // ваш код здесь
// }
// Примеры:

// console.log(fibonacci(0)); // Вывод: 0
// console.log(fibonacci(1)); // Вывод: 1
// console.log(fibonacci(2)); // Вывод: 1
// console.log(fibonacci(5)); // Вывод: 5
// console.log(fibonacci(10)); // Вывод: 55
// Ограничения:

// 0 <= n <= 30
// Базовый Алгоритм
// Конечно, вот решение задачи нахождения числа Фибоначчи с пояснением:

// Решение с Пояснением
// Для нахождения числа Фибоначчи, которое является суммой двух предыдущих чисел Фибоначчи, мы можем воспользоваться методом динамического программирования. Создадим массив, где будем хранить значения уже вычисленных чисел Фибоначчи. Изначально этот массив будет содержать два базовых значения: fib[0] = 0 и fib[1] = 1, так как первые два числа Фибоначчи равны 0 и 1 соответственно.

// Затем мы используем цикл, чтобы вычислить числа Фибоначчи от 2 до n. На каждом шаге цикла вычисляем следующее число Фибоначчи как сумму двух предыдущих чисел Фибоначчи и сохраняем его в массиве fib. После завершения цикла мы можем вернуть fib[n] как результат.

// Временная сложность этого решения составляет O(n), где n - это число Фибоначчи, которое мы хотим вычислить.

// Реализация:
/\*\*

- @param {number} n - Неотрицательное целое число, для которого нужно вычислить число Фибоначчи.
- @return {number} - n-ное число Фибоначчи.
  \*/
  function fibonacci(n) {
  // Создаем массив для хранения значений Фибоначчи
  let fib = [];
  fib[0] = 0; // Первое число Фибоначчи
  fib[1] = 1; // Второе число Фибоначчи

      // Вычисляем числа Фибоначчи от 2 до n
      for (let i = 2; i <= n; i++) {
          // Фибоначчи - это сумма двух предыдущих чисел Фибоначчи
          fib[i] = fib[i - 1] + fib[i - 2];
      }

      // Возвращаем n-ное число Фибоначчи
      return fib[n];

  }

// // Примеры использования функции
// console.log(fibonacci(0)); // Вывод: 0
// console.log(fibonacci(1)); // Вывод: 1
// console.log(fibonacci(2)); // Вывод: 1
// console.log(fibonacci(5)); // Вывод: 5
// console.log(fibonacci(10)); // Вывод: 55
// Это решение обеспечивает эффективный способ нахождения числа Фибоначчи для любого неотрицательного целого n.

// Алгоритм с кешированием
// Кеширование (или мемоизация) - это техника оптимизации, при которой результаты уже вычисленных операций сохраняются в памяти и возвращаются при последующих вызовах функции с теми же входными данными. В случае задачи вычисления числа Фибоначчи, кеширование помогает избежать избыточных вычислений и улучшает производительность функции.

// В JavaScript для реализации кеширования можно использовать объект для хранения уже вычисленных значений Фибоначчи. Вот как это можно сделать:

// Решение с Кешированием и Пояснением:
/\*\*

- @param {number} n - Неотрицательное целое число, для которого нужно вычислить число Фибоначчи.
- @return {number} - n-ное число Фибоначчи.
  \*/
  function fibonacci(n, memo = {}) {
  // Проверяем, есть ли значение в кеше
  if (n in memo) {
  return memo[n];
  }

      // Базовые случаи: F(0) = 0 и F(1) = 1
      if (n === 0) {
          return 0;
      }
      if (n === 1) {
          return 1;
      }

      // Вычисляем число Фибоначчи и сохраняем в кеше
      memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);
      return memo[n];

  }

// // Примеры использования функции с кешированием
// console.log(fibonacci(5)); // Вывод: 5 (значение сохранено в кеше, не вычисляется повторно)
// console.log(fibonacci(10)); // Вывод: 55 (вычисляется один раз и сохраняется в кеше)
// Пояснение:

// Функция fibonacci(n, memo = {}) принимает параметр n - число Фибоначчи, которое нужно вычислить, и объект memo - кеш, в котором сохраняются уже вычисленные значения.
// Перед вычислением значения для n, функция проверяет, есть ли это значение в кеше (if (n in memo)). Если значение уже вычислено, оно возвращается из кеша, что предотвращает избыточные вычисления.
// Если значение не найдено в кеше, функция вычисляет число Фибоначчи для n как сумму результатов для n-1 и n-2. Затем это значение сохраняется в кеше для будущих вызовов функции с тем же параметром n.
// Использование кеша позволяет избежать лишних вычислений и значительно ускоряет выполнение функции для больших значений n.

// ЗАДАЧА 2: Номер столбца в Excel по заголовку
// Дана строка columnTitle, представляющая заголовок столбца на листе Excel. Верните соответствующий ему номер столбца.

// Например:

// A -> 1
// B -> 2
// C -> 3
// ...
// Z -> 26
// AA -> 27
// AB -> 28
// ...
// Пример 1:

// **Вход:** columnTitle = "A"
// **Выход:** 1
// Пример 2:

// **Вход:** columnTitle = "AB"
// **Выход:** 28
// Пример 3:

// **Вход:** columnTitle = "ZY"
// **Выход:** 701
// Ограничения:

// 1 <= columnTitle.length <= 7
// columnTitle содержит только заглавные буквы английского алфавита.
// columnTitle находится в диапазоне ["A", "FXSHRXW"].
// Алгоритм 1
// Задача заключается в преобразовании заголовка столбца на листе Excel в соответствующий ему номер столбца. Заголовки столбцов в Excel обозначаются буквами английского алфавита, начиная с "A" и продолжая далее до "Z". После "Z" идут двубуквенные комбинации, начиная с "AA" и заканчивая "ZZ", затем - трехбуквенные комбинации, и так далее.

// Таким образом, для решения задачи необходимо преобразовать каждую букву в заголовке столбца в соответствующее числовое значение и вычислить итоговый номер столбца.

// Алгоритм решения:

// Инициализировать переменную result для хранения итогового номера столбца и присвоить ей значение 0.
// Проходить по каждой букве в строке columnTitle, начиная с последней.
// Для каждой буквы получить ее числовое значение, вычитая значение буквы "A" и добавляя 1.
// Умножить числовое значение каждой буквы на 26, возведенное в степень, которая равна позиции буквы в строке columnTitle.
// Прибавить полученное значение к result.
// Вернуть result как итоговый номер столбца.
// Например, для строки columnTitle = "BCD":

// На первой итерации: result = 0
// Последняя буква "D" имеет числовое значение 4.
// Умножаем 4 на 26^0 = 1.
// Прибавляем 4 к result, теперь result = 4.
// На второй итерации: result = 4.
// Предпоследняя буква "C" имеет числовое значение 3.
// Умножаем 3 на 26^1 = 26.
// Прибавляем 78 к result, теперь result = 82.
// На третьей итерации: result = 82.
// Первая буква "B" имеет числовое значение 2.
// Умножаем 2 на 26^2 = 676.
// Прибавляем 1352 к result, теперь result = 1434.
// Возвращаем 1434 как итоговый номер столбца.
// Таким образом, функция, решающая данную задачу, должна принимать строку columnTitle и возвращать соответствующий ему номер столбца.

/\*\*

- Функция принимает на вход строку columnTitle и возвращает соответствующий ему номер столбца в Excel.
- @param {string} columnTitle - Заголовок столбца на листе Excel.
- @returns {number} - Номер столбца в Excel.
  _/
  function titleToNumber(columnTitle) {
  let result = 0;
  for (let i = 0; i < columnTitle.length; i++) {
  // Получаем ASCII-код текущего символа и вычитаем ASCII-код символа 'A' для получения числового значения.
  const charCode = columnTitle.charCodeAt(i) - 'A'.charCodeAt(0) + 1;
  // Умножаем числовое значение символа на 26 в степени, соответствующей его позиции.
  result = result _ 26 + charCode;
  }
  return result;
  }

// ЗАДАЧА 3: Заголовок столбца в Excel по номеру
// Получив целое число columnNumber, верните соответствующий заголовок столбца, как он отображается в таблице Excel.

// Например:

// A -> 1
// B -> 2
// C -> 3
// ...
// Z -> 26
// AA -> 27
// AB -> 28
// ...
// Пример 1:

// **Входные данные:** columnNumber = 1
// **Выходные данные:** "A"
// Пример 2:

// **Входные данные:** columnNumber = 28
// **Выходные данные:** "AB"
// Пример 3:

// **Входные данные:** columnNumber = 701
// **Выходные данные:** "ZY"
// Ограничения:

// 1 <= columnNumber <= 231 - 1
// Алгоритм 1
// Для решения данной задачи мы можем использовать алфавит в качестве системы счисления. Каждая буква алфавита будет представлять определенное число. Например, буква "A" будет представлять число 1, буква "B" - 2, и так далее.

// Сначала мы определяем количество разрядов в искомом столбце, находим его значение в десятичной системе счисления и затем преобразуем его в соответствующий заголовок столбца.

// Для определения количества разрядов мы последовательно делим входное число на 26 и увеличиваем счетчик разрядов на 1 до тех пор, пока число не станет меньше или равно нуля.

// Затем мы начинаем со старшего разряда и находим значение каждого разряда. Для этого мы находим остаток от деления числа на 26 и определяем соответствующую букву алфавита. Затем мы делим исходное число на 26 и переходим к следующему разряду.

// Наконец, мы объединяем найденные буквы в обратном порядке и возвращаем полученный заголовок столбца.

// Например, для входного числа 28 мы имеем два разряда. Первый разряд равен (28 - 1) % 26 = 1, что соответствует букве "B". Второй разряд равен (28 - 1) / 26 - 1 = 1, что соответствует букве "A". Таким образом, заголовок столбца для числа 28 - "AB".

function convertToTitle(columnNumber) {
let result = '';
while (columnNumber > 0) {
const num = (columnNumber - 1) % 26;
result = String.fromCharCode(num + 65) + result;
columnNumber = Math.floor((columnNumber - 1) / 26);
}
return result;
}

// ЗАДАЧА 4: Количество способов подняться по лестнице
// Ты поднимаешься по лестнице. Чтобы достичь верха, нужно совершить n шагов.

// Каждый раз ты можешь подняться на 1 или 2 шага. Сколько различных способов существует, чтобы подняться на верх?

// Пример 1:

// **Входные данные:** n = 2
// **Результат:** 2
// **Объяснение:** Существует два способа подняться на верх.
// 1. 1 шаг + 1 шаг
// 2. 2 шага
// Пример 2:

// **Входные данные:** n = 3
// **Результат:** 3
// **Объяснение:** Существует три способа подняться на верх.
// 1. 1 шаг + 1 шаг + 1 шаг
// 2. 1 шаг + 2 шага
// 3. 2 шага + 1 шаг
// Ограничения:

// 1 <= n <= 45
// Алгоритм 1
// Задача заключается в том, чтобы определить количество способов подняться на верх лестницы, совершая шаги по одному или два за раз.

// Мы можем подняться на верх лестницы, начиная либо с одного шага, либо с двух шагов. Когда мы начинаем с одного шага, нам остается только подняться на оставшиеся n-1 шагов. Когда мы начинаем с двух шагов, нам остается подняться на оставшиеся n-2 шага.

// Таким образом, общее количество способов подняться на верх лестницы будет равно сумме количества способов подняться на n-1 шаг и n-2 шага.

// Мы можем использовать рекурсию, чтобы решить эту задачу. Базовый случай будет состоять из двух случаев: когда n равно 1 или 2. В этих случаях, количество способов подняться на верх лестницы будет равно 1 и 2 соответственно.

// Если n больше 2, мы можем вызвать функцию рекурсивно для n-1 и n-2 и сложить результаты.

// Также мы можем использовать динамическое программирование, чтобы избежать повторных вычислений. Мы можем создать массив dp размером n и заполнить его значениями, начиная с базовых случаев. Затем мы можем использовать этот массив, чтобы хранить промежуточные результаты, когда вызываем функцию рекурсивно.

// Таким образом, мы сможем решить задачу, определяя количество способов подняться на верх лестницы для данного n.

function climbStairs(n) {
if (n === 1) {
return 1;
}
if (n === 2) {
return 2;
}

let dp = new Array(n + 1);
dp[1] = 1;
dp[2] = 2;

for (let i = 3; i <= n; i++) {
dp[i] = dp[i - 1] + dp[i - 2];
}

return dp[n];
}

// console.log(climbStairs(2)); // 2
// console.log(climbStairs(3)); // 3

// ЗАДАЧА 5: Квадратный корень числа с округлением вниз
// Дано неотрицательное целое число x. Вернуть квадратный корень x округленный вниз до ближайшего целого числа. Возвращаемое значение также должно быть неотрицательным.

// Вы не должны использовать встроенные функции или операторы возведения в степень.

// Например, не используйте pow(x, 0.5) в c++ или x \*\* 0.5 в python.
// Пример 1:

// **Input:** x = 4
// **Output:** 2
// **Explanation:** Квадратный корень из 4 равен 2, поэтому мы возвращаем 2.
// Пример 2:

// **Input:** x = 8
// **Output:** 2
// **Explanation:** Квадратный корень из 8 равен 2.82842..., и поскольку мы округляем его вниз до ближайшего целого числа, возвращается 2.
// Ограничения:

// 0 <= x <= 231 - 1
// Алгоритм 1
// Для решения этой задачи мы можем использовать метод бинарного поиска.

// Известно, что квадратный корень x находится в диапазоне от 0 до x. Если x = 0, то корень также равен 0.

// Воспользуемся методом бинарного поиска, чтобы найти корень. Начальный левый и правый указатели будут соответствовать 0 и x соответственно.

// На каждом шаге будем брать среднее значение между левым и правым указателями и проверять, является ли его квадратом меньше или равным x. Если это так, то квадратный корень должен быть больше или равен этому значению. Поэтому перемещаем левый указатель на это значение. Если это не так, то квадратный корень должен быть меньше этого значения, поэтому перемещаем правый указатель на это значение.

// Процесс продолжается до тех пор, пока левый и правый указатели не сойдутся.

// В результате мы получим наибольшее целое число, квадрат которого не превышает x. Так как предоставленное число x неотрицательное, то полученное значение будет квадратным корнем x, округленным вниз до ближайшего целого числа.

function mySqrt(x) {
let left = 0;
let right = x;

while (left <= right) {
let mid = Math.floor((left + right) / 2);
let square = mid \* mid;

    if (square === x) {
      return mid;
    } else if (square < x) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }

}

return right;
}

// console.log(mySqrt(4)); // Output: 2
// console.log(mySqrt(8)); // Output: 2
// console.log(mySqrt(0)); // Output: 0

// ЗАДАЧА 6: Уникальные пути в сетке
// На сетке размером m x n находится робот. Робот изначально находится в верхнем левом углу (т.е. grid[0][0]). Робот пытается добраться до нижнего правого угла (т.е. grid[m - 1][n - 1]). Робот может двигаться только вниз или вправо в любой момент времени.

// Учитывая два целых числа m и n, вернуть количество возможных уникальных путей, которые робот может пройти, чтобы достичь нижнего правого угла.

// Тестовые случаи генерируются таким образом, что ответ будет меньше или равен 2 \* 109.

// Пример 1:
![image](./imgs/robot_maze.png)

// **Вход:** m = 3, n = 7
// **Выход:** 28

// Пример 2:

// **Вход:** m = 3, n = 2
// **Выход:** 3
// **Пояснение:** Из верхнего левого угла существует три способа достичь нижнего правого угла:
// 1. Вправо -> Вниз -> Вниз
// 2. Вниз -> Вниз -> Вправо
// 3. Вниз -> Вправо -> Вниз

// Ограничения:

// 1 <= m, n <= 100
// Алгоритм 1
// Данная задача связана с нахождением числа путей в сетке размером m x n. Робот может двигаться только вниз или вправо, поэтому чтобы достичь нижнего правого угла, он должен пройти m - 1 шагов вниз и n - 1 шагов вправо.

// Мы можем рассмотреть эту задачу как составление последовательности из m - 1 шагов вниз и n - 1 шагов вправо. Нам нужно выбрать позиции для шагов вниз, а остальные позиции автоматически заполнятся шагами вправо. Таким образом, число путей равно количеству способов выбрать m - 1 позицию из общего числа позиций (m - 1 + n - 1).

// Мы можем использовать формулу сочетаний для вычисления количества способов выбора m - 1 позиций из m - 1 + n - 1. Формула сочетаний записывается как:

// C(N, k) = N! / (k! \* (N - k)!)
// где N - общее количество позиций, а k - количество выбранных позиций.

// Таким образом, чтобы решить эту задачу, мы можем использовать формулу сочетаний и подставить соответствующие значения. Ответом будет количество возможных уникальных путей, которые робот может пройти.

// Однако, обратите внимание, что вычисление факториалов больших чисел может быть очень ресурсоемким и затратным с точки зрения времени ЦП и памяти. Поэтому, чтобы избежать этой проблемы, мы можем использовать динамическое программирование и методы мемоизации.

// Мы можем создать двумерный массив dp размером m x n, где dp[i][j] будет содержать количество уникальных путей, которые робот может пройти, чтобы достичь позиции (i, j). Изначально все значения dp[i][j] установлены в 1, так как для достижения верхнего края и левого края роботу не нужно делать ни одного шага.

// Затем, мы можем перебирать все позиции (i, j) от (1, 1) до (m - 1, n - 1) и обновлять значения dp[i][j] суммой значений dp[i - 1][j] и dp[i][j - 1]. Это связано с тем, что робот может достичь позиции (i, j) только из позиции (i - 1, j) (сделав шаг вниз) или из позиции (i, j - 1) (сделав шаг вправо). Таким образом, количество уникальных путей до позиции (i, j) равно сумме количества путей до позиции (i - 1, j) и количества путей до позиции (i, j - 1).

// В конце концов, dp[m - 1][n - 1] будет содержать количество уникальных путей, которые робот может пройти, чтобы достичь нижнего правого угла.

// Таким образом, решение этой задачи без использования кода заключается в вычислении количества способов выбора m - 1 позиции из m - 1 + n - 1 с помощью формулы сочетаний. Однако, чтобы избежать проблем с вычислением факториалов больших чисел, мы можем использовать динамическое программирование, создав массив dp и обновляя его значения согласно правилам перехода. В конце концов, dp[m - 1][n - 1] будет содержать искомое количество уникальных путей.

function uniquePaths(m, n) {
// Инициализация таблицы dp
const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));

// Базовый случай: инициализация первой строки и первого столбца
for (let i = 0; i < m; i++) {
dp[i][0] = 1;
}
for (let j = 0; j < n; j++) {
dp[0][j] = 1;
}

// Заполнение таблицы dp по формуле dp[i][j] = dp[i-1][j] + dp[i][j-1]
for (let i = 1; i < m; i++) {
for (let j = 1; j < n; j++) {
dp[i][j] = dp[i-1][j] + dp[i][j-1];
}
}

// Возвращаем результат из правого нижнего угла
return dp[m-1][n-1];
}

// ЗАДАЧА 7: Группировка анаграмм
// Учитывая массив строк strs, сгруппируйте анаграммы вместе. Вы можете вернуть ответ в любом порядке.

// Анаграмма - это слово или фраза, образованная путем перестановки букв другого слова или фразы, обычно с использованием всех исходных букв ровно один раз.

// Пример 1:

// **Ввод:** strs = ["eat","tea","tan","ate","nat","bat"]
// **Вывод:** [["bat"],["nat","tan"],["ate","eat","tea"]]

// Пример 2:

// **Ввод:** strs = [""]
// **Вывод:** [[""]]

// Пример 3:

// **Ввод:** strs = ["a"]
// **Вывод:** [["a"]]

// Ограничения:

// 1 <= strs.length <= 104
// 0 <= strs[i].length <= 100
// strs[i] состоит из строчных английских букв.
// Алгоритм 1
// Для решения данной задачи, мы можем воспользоваться хэш-таблицей, где ключом будет отсортированное слово, а значением - массив всех анаграмм этого слова.

// Алгоритм решения будет следующим:

// Инициализировать пустую хэш-таблицу.
// Проходить по каждому слову в массиве strs.
// Отсортировать текущее слово в алфавитном порядке.
// Если отсортированное слово уже есть в хэш-таблице, добавить текущее слово в значение этого ключа.
// Если отсортированного слова нет в хэш-таблице, создать новую пару ключ-значение, где ключ - отсортированное слово, а значение - массив, содержащий только текущее слово.
// В конце прохода по всем словам, вернуть все значения в хэш-таблице как результат.
// Таким образом, все анаграммы будут сгруппированы и возвращены в виде массива массивов.

// Пример решения:

// 1. Инициализация хэш-таблицы: {}

// 2. Первое слово "eat":
// Отсортированное слово: "aet"
// Хэш-таблица после первого слова: {"aet": ["eat"]}

// 3. Второе слово "tea":
// Отсортированное слово: "aet"
// Хэш-таблица после второго слова: {"aet": ["eat", "tea"]}

// 4. Третье слово "tan":
// Отсортированное слово: "ant"
// Хэш-таблица после третьего слова: {"aet": ["eat", "tea"], "ant": ["tan"]}

// 5. Четвертое слово "ate":
// Отсортированное слово: "aet"
// Хэш-таблица после четвертого слова: {"aet": ["eat", "tea", "ate"], "ant": ["tan"]}

// 6. Пятое слово "nat":
// Отсортированное слово: "ant"
// Хэш-таблица после пятого слова: {"aet": ["eat", "tea", "ate"], "ant": ["tan", "nat"]}

// 7. Шестое слово "bat":
// Отсортированное слово: "abt"
// Хэш-таблица после шестого слова: {"aet": ["eat", "tea", "ate"], "ant": ["tan", "nat"], "abt": ["bat"]}

// 8. Возвращаем все значения хэш-таблицы: [["eat", "tea", "ate"], ["tan", "nat"], ["bat"]]
const groupAnagrams = (strs) => {
const map = new Map();
for (let str of strs) {
const sortedStr = str.split('').sort().join('');
if (map.has(sortedStr)) {
map.get(sortedStr).push(str);
} else {
map.set(sortedStr, [str]);
}
}
const groups = [];
for (let group of map.values()) {
groups.push(group);
}
return groups;
};

// ЗАДАЧА 8: Комбинации букв из номера телефона
// Дана строка, содержащая цифры от 2 до 9 включительно. Вернуть все возможные комбинации букв, которые могут представлять данное число. Вернуть ответ в любом порядке.

// Ниже приведено соответствие цифр и букв (как на кнопках телефона). Обратите внимание, что цифра 1 не соответствует никаким буквам.

![image](./imgs/phone_keypad.png)

// Пример 1:

// **Вход:** digits = "23"
// **Выход:** ["ad","ae","af","bd","be","bf","cd","ce","cf"]

// Пример 2:

// **Вход:** digits = ""
// **Выход:** []

// Пример 3:

// **Вход:** digits = "2"
// **Выход:** ["a","b","c"]

// Ограничения:

// 0 <= digits.length <= 4
// digits[i] является цифрой в диапазоне ['2', '9'].
// Алгоритм 1
// Данная задача связана с генерацией всех возможных комбинаций букв, которые могут представлять данную цифру.

// Для решения этой задачи можно использовать рекурсивный подход. Мы можем рассмотреть каждую цифру в строке digits по очереди и сгенерировать все возможные комбинации для следующих цифр.

// Для каждой цифры, имеющей соответствующие ей буквы на кнопках телефона, мы будем рекурсивно вызывать функцию для следующей цифры. Наша базовая ситуация будет заключаться в том, что когда строка digits будет пустой, мы добавим текущую комбинацию в наш список ответов.

// Таким образом, на каждой итерации мы будем сгенерировать все возможные комбинации для текущей цифры и вызывать функцию рекурсивно для следующей цифры. После вызова рекурсивной функции для следующей цифры, мы будем объединять текущие буквы с каждой комбинацией, полученной из следующей цифры.

// Когда мы достигнем последней цифры, мы добавим полученную комбинацию в список ответов. В конце процесса мы вернем список всех возможных комбинаций букв.

// Таким образом, решение данной задачи сводится к рекурсивной генерации всех возможных комбинаций для всех цифр в строке digits.

const letterCombinations = (digits) => {
const keypad = {
'2': ['a', 'b', 'c'],
'3': ['d', 'e', 'f'],
'4': ['g', 'h', 'i'],
'5': ['j', 'k', 'l'],
'6': ['m', 'n', 'o'],
'7': ['p', 'q', 'r', 's'],
'8': ['t', 'u', 'v'],
'9': ['w', 'x', 'y', 'z']
};

const result = [];

const helper = (digits, current = '') => {
if (digits.length === 0) {
if (current !== '') {
result.push(current);
}
return;
}

    const letters = keypad[digits[0]];
    for (let i = 0; i < letters.length; i++) {
      helper(digits.slice(1), current + letters[i]);
    }

};

helper(digits);

return result;
};
// Описание решения:

// Создаем объект keypad, в котором хранится соответствие цифр и букв на клавиатуре телефона.
// Создаем пустой массив result, в который будут добавляться все возможные комбинации букв.
// Создаем функцию helper, которая будет рекурсивно собирать все комбинации букв. Она принимает два аргумента: digits - оставшиеся цифры, и current - текущая комбинация букв.
// В теле функции helper:
// Проверяем, если digits.length === 0, значит все цифры были использованы и можно добавить текущую комбинацию current в массив result.
// Если current !== '', то добавляем current в массив result.
// Рекурсивно вызываем функцию helper со срезом digits.slice(1) (оставшиеся цифры) и новой комбинацией current + letters[i].
// Вызываем функцию helper со значением digits.
// Возвращаем массив result.

// ЗАДАЧА 9: Конвертация числа в римскую цифру
// Римские цифры представлены семью различными символами: I, V, X, L, C, D и M.

// **Символ** **Значение**
// I 1
// V 5
// X 10
// L 50
// C 100
// D 500
// M 1000
// Например, 2 записывается как II в римских цифрах, просто две единицы сложены вместе. 12 записывается как XII, что означает X + II. Число 27 записывается как XXVII, что означает XX + V + II.

// Римские цифры обычно записываются от большего к меньшему слева направо. Однако, число четыре не записывается как IIII. Вместо этого, число 4 записывается как IV. Потому что единица стоит перед пятью, мы вычитаем ее и получаем четыре. Тот же принцип применяется к числу девять, которое записывается как IX. Есть шесть случаев, в которых используется вычитание:

// I может стоять перед V (5) и X (10), чтобы получить 4 и 9.
// X может стоять перед L (50) и C (100), чтобы получить 40 и 90.
// C может стоять перед D (500) и M (1000), чтобы получить 400 и 900.
// Дано целое число, конвертируйте его в римскую цифру.

// Пример 1:

// **Ввод:** num = 3
// **Вывод:** "III"
// **Объяснение:** 3 представляется тремя единицами.

// Пример 2:

// **Ввод:** num = 58
// **Вывод:** "LVIII"
// **Объяснение:** L = 50, V = 5, III = 3.

// Пример 3:

// **Ввод:** num = 1994
// **Вывод:** "MCMXCIV"
// **Объяснение:** M = 1000, CM = 900, XC = 90 и IV = 4.

// Ограничения:

// 1 <= num <= 3999
// Алгоритм 1
// Дано целое число num. Нам требуется сконвертировать его в римскую цифру.

// Для решения этой задачи мы будем использовать жадный подход, который заключается в том, чтобы каждый раз выбирать наибольшую возможную римскую цифру, которая помещается в num. Затем мы вычитаем значение этой цифры из num и добавляем соответствующий символ в итоговую строку.

// Мы создаем массив digits с римскими цифрами 'I', 'IV', 'V', 'IX', 'X', 'XL', 'L', 'XC', 'C', 'CD', 'D', 'CM', 'M' и их значениями [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]. Обратите внимание, что некоторые числа записаны в виде комбинации двух символов (например, 'IV' для числа 4) для обработки случаев вычитания.

// Затем мы проходим по массиву digits в обратном порядке (начиная с наибольшей цифры) и проверяем, если num больше или равно текущему значению. Если это верно, мы вычитаем значение из num и добавляем символ в итоговую строку, повторяя это до тех пор, пока num не станет равным нулю.

// В конце мы получаем искомую римскую цифру.

// Например, для числа 58, мы начинаем с наибольшего значения 50 (соответствующего символу 'L') и вычитаем это значение из num, получая num = 8. Затем мы проверяем, что num больше либо равно следующей цифре 9, и вычитаем ее из num, получая num = -1. Теперь итоговая строка будет 'LVIII'.

// Сложность данного решения составляет O(1), так как количество доступных римских цифр ограничено и не зависит от величины числа num.

function intToRoman(num) {
let roman = "";
const symbols = [
{ value: 1000, symbol: "M" },
{ value: 900, symbol: "CM" },
{ value: 500, symbol: "D" },
{ value: 400, symbol: "CD" },
{ value: 100, symbol: "C" },
{ value: 90, symbol: "XC" },
{ value: 50, symbol: "L" },
{ value: 40, symbol: "XL" },
{ value: 10, symbol: "X" },
{ value: 9, symbol: "IX" },
{ value: 5, symbol: "V" },
{ value: 4, symbol: "IV" },
{ value: 1, symbol: "I" }
];

for (const symbol of symbols) {
while (num >= symbol.value) {
roman += symbol.symbol;
num -= symbol.value;
}
}

return roman;
}

// ЗАДАЧА 10: Переворот цифр целого числа в 32-битовом диапазоне
// Учитывая целое число x со знаком в 32 бита, верните x с перевёрнутыми цифрами. Если обратное x приводит к значению, выходящему за границы диапазона целых чисел в 32 бита [-231, 231 - 1], то верните 0.

// Предположим, что среда не позволяет вам хранить 64-битные целые числа (со знаком или без знака).

// Пример 1:

// **Ввод:** x = 123
// **Вывод:** 321
// Пример 2:

// **Ввод:** x = -123
// **Вывод:** -321
// Пример 3:

// **Ввод:** x = 120
// **Вывод:** 21
// Ограничения:

// -231 <= x <= 231 - 1
// Алгоритм 1
// Интуиция

// Мы можем построить обратное целое число, по одной цифре за раз. При этом мы можем предварительно проверить, приведет ли добавление еще одной цифры к переполнению.

// Алгоритм

// Обратное целое число можно получить аналогично обратному порядку символов в строке.

// Мы хотим повторять операцию «выталкивания» последней цифры из числа xxx и перемещения ее в конец rev\text{rev}rev. В конечном итоге rev\text{rev}rev станет обратным к ххх.

// Для «выталкивания» и «помещения» цифр без помощи стека/массива можно использовать математику.

// // операция выталкивания: pop = x % 10; x /= 10;

// // операция помещения: temp = rev \* 10 + pop; rev = temp;

// Однако этот подход опасен, потому что операция temp=rev⋅10+pop\text{temp} = \text{rev} \cdot 10 + \text{pop}temp=rev⋅10+pop может вызвать переполнение.

// К счастью, легко проверить заранее, вызовет ли данное выражение переполнение.

// Для объяснения предположим, что rev\text{rev}rev положителен.

// Если temp=rev⋅10+poptemp = \text{rev} \cdot 10 + \text{pop}temp=rev⋅10+pop вызывает переполнение, то это означает, что rev≥INTMAX10\text{rev} \geq \frac{INTMAX}{10}rev≥10INTMAX​
// Если rev>INTMAX10\text{rev} > \frac{INTMAX}{10}rev>10INTMAX​, то temp=rev⋅10+poptemp = \text{rev} \cdot 10 + \text{pop}temp=rev⋅10+pop гарантировано вызовет переполнение.
// Если rev==INTMAX10\text{rev} == \frac{INTMAX}{10}rev==10INTMAX​, то temp=rev⋅10+poptemp = \text{rev} \cdot 10 + \text{pop}temp=rev⋅10+pop вызовет переполнение, если и только если pop>7\text{pop} > 7pop>7
// Аналогичная логика может быть применена, когда rev\text{rev}rev отрицательное.

// Анализ сложности

// Временная сложность: O(log⁡(x))O(\log(x))O(log(x)). В числе ххх примерно log⁡10(x)\log\_{10}(x)log10​(x) цифр.
// Пространственная сложность: O(1)O(1)O(1).
function reverse(x) {
let rev = 0;
while (x !== 0) {
let pop = x % 10;
x = parseInt(x / 10);
if (rev > Number.MAX_VALUE / 10 || (rev === Number.MAX_VALUE / 10 && pop > 7)) return 0;
if (rev < Number.MIN_VALUE / 10 || (rev === Number.MIN_VALUE / 10 && pop < -8)) return 0;
rev = rev \* 10 + pop;
}
return rev;
}

// ЗАДАЧА 11: Сравнение номеров версий
// Учитывая два номера версий, version1 и version2, сравните их.

// Номера версий состоят из одного или нескольких номеров редакции, объединенных точкой '.'. Каждая редакция состоит из цифр и может содержать ведущие нули. Каждая редакция содержит по крайней мере один символ. Редакции индексируются с нуля слева направо, при этом левая редакция - редакция 0, следующая редакция - редакция 1 и так далее. Например, 2.5.33 и 0.1 являются допустимыми номерами версий.

// Для сравнения номеров версий сравните их редакции в порядке слева направо. Редакции сравниваются с использованием их целочисленного значения с игнорированием ведущих нулей. Это означает, что редакции 1 и 001 считаются равными. Если номер версии не указывает редакцию по индексу, то считайте редакцию равной 0. Например, версия 1.0 меньше, чем версия 1.1, потому что их редакции 0 равны, но их редакции 1 соответственно равны 0 и 1, и 0 < 1.

// Вернуть следующее:

// Если version1 < version2, вернуть -1.
// Если version1 > version2, вернуть 1.
// В противном случае вернуть 0.
// Пример 1:

// **Ввод:** version1 = "1.01", version2 = "1.001"
// **Вывод:** 0
// **Объяснение:** Если игнорировать ведущие нули, то и "01", и "001" представляют одно и то же целое число "1".
// Пример 2:

// **Ввод:** version1 = "1.0", version2 = "1.0.0"
// **Вывод:** 0
// **Объяснение:** версия 1 не указывает редакцию 2, поэтому она считается "0".
// Пример 3:

// **Ввод:** version1 = "0.1", version2 = "1.1"
// **Вывод:** -1
// **Объяснение:** редакция 0 версии 1 равна "0", тогда как редакция 0 версии 2 равна "1". 0 < 1, поэтому версия 1 < версии 2.
// Ограничения:

// 1 <= version1.length, version2.length <= 500
// version1 и version2 содержат только цифры и '.'.
// version1 и version2 являются допустимыми номерами версий.
// Все указанные редакции в version1 и version2 могут быть сохранены в 32-битном целом числе.
// Алгоритм 1
// Для решения этой задачи нужно сравнивать редакции номеров версий version1 и version2 по очереди, начиная с самой левой редакции.

// Разделяем номера версий на редакции, используя разделитель '.'.
// Сравниваем редакции по очереди:
// Если в обоих номерах версий остались еще редакции, сравниваем их целочисленные значения, игнорируя ведущие нули.
// Если в одном из номеров версий закончились редакции, считаем отсутствующие редакции равными 0.
// Если найденная редакция в version1 меньше редакции в version2, возвращаем -1.
// Если найденная редакция в version1 больше редакции в version2, возвращаем 1.
// Если все редакции совпадают, значит номера версий равны и возвращаем 0.
function compareVersion(version1, version2) {
let v1 = version1.split('.');
let v2 = version2.split('.');

// Добавляем нули в конец короткой версии, чтобы их можно было одинаково сравнить
while (v1.length < v2.length) {
v1.push('0');
}
while (v2.length < v1.length) {
v2.push('0');
}

// Сравниваем редакции по порядку
for (let i = 0; i < v1.length; i++) {
let num1 = parseInt(v1[i]);
let num2 = parseInt(v2[i]);

    if (num1 < num2) {
      return -1;
    } else if (num1 > num2) {
      return 1;
    }

}

// Все редакции равны
return 0;
}

// // Примеры использования
// console.log(compareVersion("1.01", "1.001")); // 0
// console.log(compareVersion("1.0", "1.0.0")); // 0
// console.log(compareVersion("0.1", "1.1")); // -1

// ЗАДАЧА 12: Нулевые цифры факториала
// Дано целое число n. Вернуть количество конечных нулей в n!

// Заметим, что n! = n _ (n - 1) _ (n - 2) _ ... _ 3 _ 2 _ 1.

// Пример 1:

// **Входные данные:** n = 3
// **Выходные данные:** 0
// **Пояснение:** 3! = 6, конечные нули отсутствуют.
// Пример 2:

// **Входные данные:** n = 5
// **Выходные данные:** 1
// **Пояснение:** 5! = 120, один конечный ноль.
// Пример 3:

// **Входные данные:** n = 0
// **Выходные данные:** 0
// Ограничения:

// 0 <= n <= 104
// Дополнение: Можете ли вы написать решение, работающее за логарифмическое время?

// Алгоритм 1
// Объяснение решения:

// Для решения данной задачи, нам нужно вычислить факториал числа n и посчитать количество конечных нулей в его записи.

// Заметим, что нули в конце числа n! образуются при умножении чисел на 10, то есть когда находимся в multipla числа 10.

// Поскольку 10 = 2 \* 5, чтобы получить 10, нужно умножить число на 2 и 5. Но в факториале числа n, у нас всегда будет более чем достаточно двоек, поскольку в каждом четном числе есть фактор 2. Значит, нам нужно узнать только количество факторов 5 в числе n!.

// Чтобы найти количество факторов 5 в числе n!, мы можем просто поделить n на 5 и получить целое число. Затем поделим это целое число на 5 и так далее, до тех пор, пока результат деления не станет равен 0. Итоговая сумма всех целых чисел, полученных в результате деления, будет являться количеством факторов 5 в числе n!.

// Данный подход работает потому, что в числах, кратных 5, имеется один фактор 5, в числах, кратных 25, имеется два фактора 5, в числах, кратных 125, имеется три фактора 5 и так далее.

// Данное решение работает за логарифмическое время в зависимости от значения n, поскольку мы делим n на 5, затем на 25, затем на 125 и так далее до тех пор, пока результат деления не станет равен 0. Таким образом, время выполнения алгоритма зависит от количества раз, которое n можно разделить на 5, что является логарифмической функцией от n.

// Таким образом, нам необходимо только реализовать данный подход в коде и вернуть итоговую сумму всех целых чисел, полученных в результате деления.

// Однако, в случае n = 0, факториал числа будет равен 1, и в нем не будет конечных нулей, поэтому в этом случае мы должны вернуть 0.

// Решение со сложностью O(n)
function countTrailingZeroes(n) {
let factorial = 1;
for (let i = 2; i <= n; i++) {
factorial \*= i;
}

let count = 0;
while (factorial % 10 === 0) {
count++;
factorial /= 10;
}

return count;
}

// Решение со сложностью O(log n)
function countTrailingZeroes(n) {
let count = 0;
while (n > 0) {
n = Math.floor(n / 5);
count += n;
}
return count;
}
