# 1. Что такое Shadow DOM

Shadow DOM
Теневой DOM («Shadow DOM») используется для инкапсуляции. Благодаря ему в компоненте есть собственное «теневое» DOM-дерево, к которому нельзя просто так обратиться из главного документа, у него могут быть изолированные CSS-правила и т.д.

Каждый DOM-элемент может иметь 2 типа поддеревьев DOM:

Light tree – обычное, «светлое», DOM-поддерево, состоящее из HTML-потомков. Все поддеревья, о которых мы говорили в предыдущих главах, были «light».

Shadow tree – скрытое, «теневое», DOM-поддерево, не отражённое в HTML, скрытое от посторонних глаз.

Если у элемента имеются оба поддерева, браузер отрисовывает только теневое дерево. Также мы всё же можем задать «композицию» теневого и обычного деревьев.

Теневое дерево можно использовать в пользовательских элементах (Custom Elements), чтобы спрятать внутренности компонента и применить к ним локальные стили.

Например, этот

```js
<script>
customElements.define('show-hello', class extends HTMLElement {
  connectedCallback() {
    const shadow = this.attachShadow({mode: 'open'});
    shadow.innerHTML = `<p>
      Hello, ${this.getAttribute('name')}
    </p>`;
  }
});
</script>

<show-hello name="John"></show-hello>
```

# 2. В чем разница между классовыми и функциональными компонентами

Разница между классовыми и функциональными компонентами заключается в способе определения и использования компонентов в React.

Синтаксис и объявление:
Классовые компоненты: Определяются как классы, расширяющие React.Component. Имеют конструктор и методы жизненного цикла (например, componentDidMount, render и т.д.).

Функциональные компоненты: Определяются как обычные функции. Вводятся с помощью функции, принимающей пропсы и возвращающей JSX (или другие элементы).

Структура кода:
Классовые компоненты: Обычно требуют больше кода из-за объявления класса, наличия конструктора и необходимости биндинга методов в случае использования обработчиков событий.

Функциональные компоненты: Требуют меньше кода, так как они просто функции. Введение хуков (hooks) дало им способность управлять состоянием и использовать другие функциональные возможности, которые ранее были доступны только классовым компонентам.

Состояние и жизненный цикл:
Классовые компоненты: Имеют полный доступ к состоянию и жизненному циклу. Это было классическим способом управления состоянием компонентов до введения хуков.

Функциональные компоненты: Сначала функциональные компоненты были более ограниченными, но с введением хуков (например, useState, useEffect и т.д.), они теперь могут управлять состоянием и жизненным циклом аналогично классовым компонентам.

Производительность:
Классовые компоненты: Исторически они могли вызывать некоторые проблемы с производительностью из-за необходимости связывать обработчики событий и жизненные циклы.

Функциональные компоненты: С хуками и введением оптимизаций, таких как React.memo, функциональные компоненты обычно имеют лучшую производительность.

Требования к версии:
Классовые компоненты: Могут использоваться в любой версии React.

Функциональные компоненты: Требуют версию React 16.8 и выше для использования хуков.

Следует отметить, что на данный момент большинство новых компонентов в React создаются в функциональном стиле из-за простоты, легкости тестирования и развивающегося набора функциональных возможностей, предоставляемых хуками.

Классовые компоненты
Раньше, когда React был в версии до 16.8, классовые компоненты были основным способом создания компонентов. Они имеют встроенное состояние (state) и поддерживают методы жизненного цикла. Вот пример классового компонента:

```js
import React, { Component } from "react";

class ClassComponent extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0,
    };
  }

  handleClick() {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={() => this.handleClick()}>Increment</button>
      </div>
    );
  }
}
```

Функциональные компоненты
Введение хуков (hooks) в React 16.8 позволило использовать функциональные компоненты как более простой и предпочтительный способ создания компонентов. Они не имеют встроенного состояния и используют хуки, такие как useState, useEffect и другие, для управления состоянием и выполнения побочных эффектов. Вот пример функционального компонента:

```js
import React, { useState } from "react";

function FunctionalComponent() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}
```

Функциональные компоненты
Хуки (hooks), введенные в React 16.8, позволили функциональным компонентам иметь состояние и выполнять побочные эффекты без необходимости создания класса. Это сделало функциональные компоненты более простыми и понятными для разработчиков.
Хуки, такие как useState, useEffect, useContext и другие, предоставляют более гибкий и мощный способ управления состоянием и выполнения действий в функциональных компонентах.
Функциональные компоненты обычно имеют меньший объем кода и легче поддерживаются. Они позволяют разделить компоненты на более мелкие и переиспользуемые блоки, что способствует повторному использованию кода и облегчает его тестирование.
Функциональные компоненты работают быстрее, чем классовые компоненты, благодаря отсутствию накладных расходов на создание экземпляра класса.
Классовые компоненты
Классовые компоненты были первоначальным способом создания компонентов в React. Они имеют встроенное состояние (state) и методы жизненного цикла, такие как componentDidMount, componentDidUpdate, componentWillUnmount и другие.
Методы жизненного цикла классовых компонентов предоставляют возможность выполнения определенных действий на различных этапах жизненного цикла компонента, например, инициализация состояния, загрузка данных или очистка ресурсов перед удалением компонента.
Классовые компоненты могут быть полезны, если вам требуется управлять сложным состоянием, которое требует более продвинутых операций, или если вы работаете с кодом, который использует старые версии React и не поддерживает функциональные компоненты.

# 3. Что такое VirtualDOM

Концепция виртуального DOM в простых словах заключается в том, что React создает свою собственную копию страницы (виртуальный DOM) в памяти компьютера. Когда происходят изменения в состоянии или данных, React сравнивает эту копию с настоящей страницей (реальный DOM) и выясняет, какие части страницы нужно обновить. Затем React применяет только необходимые изменения на странице, минимизируя количество работы, которое нужно сделать для обновления пользовательского интерфейса.

Использование виртуального DOM позволяет React работать более эффективно и быстро обновлять пользовательский интерфейс. Вместо того, чтобы каждый раз перерисовывать всю страницу при изменении данных, React анализирует только изменения и обновляет только те части страницы, которые действительно нуждаются в обновлении. Это позволяет сделать взаимодействие с веб-приложением более плавным и отзывчивым для пользователей.

# 4. В чем разница между виртуальным DOM и обычным?

Основная идея виртуального DOM (VDOM) в React заключается в оптимизации процесса обновления пользовательского интерфейса, что позволяет повысить производительность при работе с динамическими веб-приложениями.

Вот как это работает:
Реальный DOM: Веб-страницы строятся на основе дерева элементов HTML, которое называется Реальным DOM. Каждый раз, когда данные в приложении меняются, Реальный DOM должен быть обновлен, что может привести к затратам по производительности, так как обновление DOM - операция ресурсоемкая.

Виртуальный DOM: Виртуальный DOM - это виртуальное представление Реального DOM, созданное на стороне JavaScript. Каждый компонент в React имеет свое представление в Виртуальном DOM. Это представление является легким и быстрым для обновления.

Обновление: Когда состояние компонента меняется, React сначала обновляет Виртуальный DOM. Затем происходит процесс сравнения предыдущего и нового состояний Виртуального DOM. Этот процесс называется "сверка" (reconciliation).

Diffing: React сравнивает старое и новое состояния Виртуального DOM, чтобы выяснить, какие части интерфейса нужно обновить. Это делается путем сравнения структуры и значений узлов.

Минимизация мутаций: React определяет минимальное количество изменений, которое необходимо внести в Реальный DOM, чтобы обновить его до нового состояния Виртуального DOM. Это уменьшает накладные расходы, связанные с манипуляциями с DOM.

Пакетная обработка: React собирает все изменения, которые должны быть применены к Реальному DOM, и применяет их пакетно. Это позволяет избежать лишних перерисовок и оптимизировать процесс обновления интерфейса.

Используя Виртуальный DOM, React сокращает нагрузку на браузер, улучшает производительность и предоставляет более удобные средства для работы с интерфейсом.

# 5. Что такое React? Зачем он нужен? Какие задачи решает?

React - это библиотека JavaScript для создания пользовательских интерфейсов. Она позволяет разработчикам создавать компоненты, которые могут быть повторно использованы в разных частях приложения. React решает несколько задач, таких как:

Управление состоянием: React позволяет управлять состоянием приложения с помощью компонентов. Каждый компонент имеет свое состояние, которое может быть изменено только через определенные методы.

Рендеринг: React использует дерево компонентов для отображения интерфейса. Каждый компонент рендерит свой собственный HTML-код, который затем отображается на странице.

Обновление: React обновляет только те части интерфейса, которые изменились. Это позволяет ускорить работу приложения и сделать его более эффективным.

Модульность: React позволяет разбивать приложение на модули, которые могут быть повторно использованы в разных частях. Это упрощает разработку и поддержку приложения.

Гибкость: React позволяет разработчикам создавать гибкие и масштабируемые приложения. Он предоставляет множество инструментов для управления состоянием, рендерингом и обновлением.

React является одной из самых популярных библиотек для создания пользовательских интерфейсов веб-приложений. Она широко используется во многих компаниях и проектах, и имеет большое сообщество разработчиков, которые создают множество дополнительных инструментов и библиотек для упрощения разработки.

# 6. Реакт быстрый из-за того, что он сравнивает реальный дом и виртуал дом. Можешь рассказать как это происходит?

Когда вы используете React, виртуальный DOM используется для ускорения процесса обновления пользовательского интерфейса. Виртуальный DOM - это копия реального DOM, которая хранится в памяти и обновляется только при изменении состояния компонентов.

Когда вы изменяете состояние компонента, React обновляет виртуальный DOM, а затем сравнивает его с предыдущим виртуальным DOM. Если изменения были внесены, React обновляет реальный DOM, чтобы отобразить изменения.

Однако, если вы изменяете состояние компонента слишком часто, React может не успеть сравнить виртуальные DOM и обновить реальный DOM в режиме реального времени. В этом случае, React может обновить реальный DOM только после того, как пользователь закончит перемещать элементы на страницу.

Таким образом, если вы хотите обновлять состояние компонента слишком часто, вам может потребоваться использовать другие методы, такие как setTimeout или requestAnimationFrame, чтобы уменьшить количество обновлений.

# 7. В чем разница между NextJS и ReactJS

Next.js и ReactJS - это две разные библиотеки для создания пользовательских интерфейсов на языке JavaScript.

Next.js - это фреймворк для создания быстрых и масштабируемых веб-приложений на основе React. Он предоставляет множество инструментов и функций, которые упрощают разработку, таких как автоматическая оптимизация, серверный рендеринг и маршрутизация. Next.js также поддерживает использование TypeScript и других языков программирования на стороне клиента.

ReactJS - это библиотека для создания пользовательских интерфейсов на языке JavaScript. Она предоставляет множество инструментов и функций для создания компонентов, управления состоянием и обработки событий. ReactJS также поддерживает использование TypeScript и других языков программирования на стороне клиента.

Основная разница между Next.js и ReactJS заключается в том, что Next.js является фреймворком, который упрощает разработку веб-приложений, в то время как ReactJS является библиотекой, которая предоставляет инструменты для создания пользовательских интерфейсов. Next.js предоставляет множество инструментов и функций, которые упрощают разработку, в то время как ReactJS предоставляет только базовые инструменты для создания компонентов и управления состоянием.

# 8. В чём отличие ReactDOM.render от ReactDOM.hydrate (или createRoot от hydrateRoot )?

ReactDOM.render и ReactDOM.hydrate являются двумя разными методами в библиотеке React для рендеринга компонентов. Они имеют следующие отличия:

Используемое начальное состояние:

ReactDOM.render: Этот метод используется для первоначального рендеринга компонентов на стороне клиента (client-side rendering) или на сервере (server-side rendering). Он не предполагает наличие предыдущего состояния на стороне клиента и начинает рендеринг с нуля.
ReactDOM.hydrate: Этот метод также используется для рендеринга компонентов, но предполагает наличие предыдущего HTML-содержимого на стороне клиента. Он применяется, когда React пытается "гидратировать" (hydrate) существующее HTML-содержимое и связать его с соответствующими компонентами. Это важно для оптимизации производительности, так как React пытается сохранить согласованность между виртуальным DOM и реальным DOM, включая обработку событий и сохранение состояния.
Применение:

ReactDOM.render: Используется для рендеринга на стороне клиента в том случае, когда у вас нет предыдущего HTML-содержимого для "гидратации".
ReactDOM.hydrate: Используется для рендеринга на стороне клиента, когда у вас уже есть предыдущее HTML-содержимое, которое было сгенерировано на сервере или на стороне клиента и затем отправлено на сервер и получено обратно (по обычному процессу серверного рендеринга или через такие инструменты, как Next.js). Этот метод помогает React сохранить согласованность существующего состояния на стороне клиента.
Что касается createRoot и hydrateRoot, они предоставляют альтернативный способ для рендеринга компонентов, вводимый в React 18. Эти методы используются в новой модели совместного рендеринга (Concurrent Mode) и заменяют старый метод ReactDOM.render. Они обеспечивают более гибкий и предсказуемый способ рендеринга компонентов, а также позволяют React оптимально управлять приоритетами и работать в режиме "совместной работы" для более высокой производительности. hydrateRoot в основном используется для гидратации уже существующего контента, а createRoot - для создания нового корневого узла для рендеринга.

# 9. Расскажи процесс рендеринга в React

Процесс рендеринга в React включает в себя следующие шаги:

Создание компонента: Сначала необходимо создать компонент в React. Компонент может быть создан с помощью функционального или классового компонента.

Создание элемента: Затем необходимо создать элемент, который будет использоваться для рендеринга компонента. Элемент может быть создан с помощью функции React.createElement() , которая принимает имя компонента и его свойства в качестве аргументов.

Рендеринг элемента: После создания элемента, его необходимо рендерить на странице. Для этого необходимо вызвать функцию ReactDOM.render() , которая принимает созданный элемент и элемент DOM, на который будет рендериться компонент.

Обновление компонента: Компонент может быть обновлен в режиме реального времени, изменяя его состояние и свойства. При каждом изменении компонента, React перерендеривает его, чтобы отобразить изменения на странице.

Очистка памяти: После того, как компонент больше не нужен, его необходимо удалить из памяти, чтобы избежать утечек памяти. Для этого необходимо вызвать функцию ReactDOM.unmountComponentAtNode() , которая принимает элемент DOM, на который был рендерен компонент, и удаляет его из памяти.

В целом, процесс рендеринга в React включает в себя создание компонента, создание элемента, рендеринг элемента, обновление компонента и очистку памяти. Эти шаги позволяют создавать интерактивные пользовательские интерфейсы в React.
