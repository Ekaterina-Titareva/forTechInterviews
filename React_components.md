# 1. Что такое HOC?

HOC (Higher-Order Component) - это паттерн высшего порядка в React, который позволяет переиспользовать логику компонентов и расширять их функциональность. HOC - это функция, которая принимает компонент и возвращает новый компонент.

Основная идея HOC заключается в том, чтобы изолировать общую логику или функциональность компонентов и вынести ее в отдельный компонент-обертку. Это позволяет использовать эту общую логику в разных компонентах без необходимости дублирования кода.

Пример использования HOC может быть следующим:

```js
function withLogger(WrappedComponent) {
  return class extends React.Component {
    componentDidMount() {
      console.log("Компонент был отрисован");
    }

    render() {
      return <WrappedComponent {...this.props} />;
    }
  };
}

// Компонент, к которому мы хотим добавить логирование
class MyComponent extends React.Component {
  render() {
    return <div>Привет, мир!</div>;
  }
}

// Оборачиваем компонент с помощью HOC
const EnhancedComponent = withLogger(MyComponent);
```

В приведенном выше примере withLogger является HOC. Он принимает компонент MyComponent в качестве аргумента и возвращает новый компонент, который добавляет логирование в метод componentDidMount. Затем мы можем использовать EnhancedComponent вместо MyComponent, и при каждом отрисовке EnhancedComponent будет выводить сообщение в консоль.

HOC являются мощным инструментом для переиспользования логики и функциональности в React. Они могут использоваться для добавления аспектов, таких как логирование, аутентификация, обработка ошибок и многое другое, в компоненты без изменения самих компонентов.

# 2. styled components react, плюсы и минусы

Существует множество инструментов для стилизации компонентов React, и выбор зависит от ваших потребностей и предпочтений. Однако, есть несколько плюсов и минусов, которые следует учитывать при выборе инструмента:

Плюсы:

Большое сообщество разработчиков и пользователей, что означает, что вы можете найти множество решений и подходов к стилизации компонентов.
Возможность использования переменных, миксинов, функций и других функций Sass, что делает ваш код более модульным и легко поддерживаемым.
Возможность использования CSS-модулей, что позволяет легко организовывать ваш код и упрощать его поддержку.
Возможность использования инструментов для автоматической генерации стилей, таких как PostCSS или Stylus, что упрощает процесс разработки и поддержки.
Минусы:

Некоторые инструменты могут иметь большую степень адаптации и требовать большего времени на настройку и использование.
Некоторые инструменты могут иметь большую степень зависимости от конкретной конфигурации проекта, что может быть проблемой при переносе проекта на другую платформу или в другое приложение.
Некоторые инструменты могут иметь большую степень сложности и требовать большого опыта в разработке компонентов.
В целом, выбор инструмента для стилизации компонентов React зависит от ваших потребностей и предпочтений, а также от конкретных требований вашего проекта.

# 3. React Portal

React Portal - это механизм, предоставляемый библиотекой React, который позволяет разработчикам рендерить дочерние компоненты вне их родительского компонента и вставлять их в другое место в DOM-дереве. Это позволяет создавать компоненты, которые визуально находятся в одном месте в иерархии компонентов, но фактически рендерятся в другом месте в DOM.

Использование React Portal полезно в следующих случаях:

Модальные окна и всплывающие сообщения: Порталы позволяют разработчикам создавать модальные окна или всплывающие сообщения и вставлять их непосредственно в < body> или другие контейнеры, обеспечивая независимость от иерархии компонентов и предотвращая возможные проблемы с позиционированием и слоем наложения.

Интеграция с внешними библиотеками: Если вы используете сторонние библиотеки или скрипты, которые ожидают определенную DOM-структуру, вы можете использовать порталы для вставки компонентов в нужное место в DOM, не нарушая целостность остальной части приложения.

Управление порядком слоев: Порталы позволяют контролировать порядок слоев компонентов и управлять их взаимодействием с другими элементами на странице.

Пример использования React Portal:

```js
import React from "react";
import ReactDOM from "react-dom";

const Modal = ({ children }) => {
  return ReactDOM.createPortal(
    <div className="modal">{children}</div>,
    document.getElementById("modal-root")
  );
};

const App = () => {
  return (
    <div>
      <h1>My App</h1>
      <Modal>
        <p>This is a modal window</p>
      </Modal>
    </div>
  );
};

ReactDOM.render(<App />, document.getElementById("root"));
```

В приведенном примере < Modal> компонент рендерится внутри <div id="modal-root"> вне иерархии компонентов < App>.
Это позволяет модальному окну отображаться над остальным содержимым страницы, независимо от иерархии компонентов.

# 4. Как организуются компоненты?

Организуются следующим образом:

Создайте новый файл с расширением.js или.jsx в папке компонентов вашего проекта.
В этом файле определите функцию-компонент, которая будет возвращать JSX-разметку.
Импортируйте этот компонент в другой файл, где вы хотите использовать его.
Используйте этот компонент в JSX-разметке, как обычный HTML-элемент.
Например, если вы хотите создать компонент для кнопки, вы можете создать файл Button.js со следующим содержимым:

```js
React from 'react';

function Button(props) {
return (
<button onClick={props.onClick}>
{props.label}
</button>
);
}

export default Button;
```

Затем вы можете импортировать этот компонент в другой файл и использовать его в JSX-разметке:

```js
React from 'react';
import Button from './Button';

function App() {
function handleClick() {
console.log('Button clicked!');
}

return (

<div>
<Button label="Click me" onClick={handleClick} />
</div>
);
}

export default App;
```

В этом примере компонент Button принимает два свойства: label (строка) и onClick (функция). Он возвращает кнопку с этими свойствами и обработчиком события onClick. В файле App.js мы используем этот компонент, передавая ему свойства и обработчик события.

# 5. Расскажите про процесс reconciliation в React

Reconciliation в React - это процесс, который позволяет React обновлять и отображать только те компоненты, которые изменились, вместо обновления всего дерева компонентов. Это позволяет ускорить работу приложения и сделать его более эффективным.

Процесс reconciliation в React включает в себя следующие шаги:

React создает новое дерево компонентов, которое соответствует текущему состоянию приложения.

React сравнивает новое дерево компонентов с предыдущим деревом компонентов.

React определяет, какие компоненты были добавлены, изменены или удалены между новым и предыдущим деревом компонентов.

React обновляет только те компоненты, которые были изменены, добавлены или удалены.

React обновляет DOM только для тех компонентов, которые были изменены.

React вызывает жизненный цикл методов жизненного цикла (например, componentDidMount, componentDidUpdate и т.д.) только для тех компонентов, которые были изменены.

Таким образом, процесс reconciliation в React позволяет обновлять и отображать только те компоненты, которые изменились, что ускоряет работу приложения и сделает его более эффективным.

# 6. Компонент React Offscreen – зачем он нужен?

Компонент Offscreen в React не является встроенным компонентом или частью стандартной библиотеки React. Рассмотрим, зачем может быть полезным использование подобного рендеринга.

Offscreen Rendering (Рендеринг за пределами видимой области):

"Offscreen rendering" - это техника, которая позволяет выполнять рендеринг содержимого вне видимой области экрана. Это может быть полезно в нескольких сценариях:

Предварительная загрузка контента: Вы можете загрузить и подготовить контент на невидимой части страницы, чтобы он был готов к отображению, когда пользователь будет готов к его просмотру. Это особенно полезно для веб-приложений с большим объемом данных, таких как виртуальные списки или сложные графики.

Повышение производительности: Рендеринг компонентов за пределами видимой области может снизить нагрузку на графический процессор и CPU. Это особенно актуально для сложных анимаций или графики, которая может вызвать задержки при рендеринге.

Использование вместе с техниками анимации: Если у вас есть анимированный контент, который должен появляться или исчезать на странице, предварительный рендеринг за пределами видимой области может улучшить плавность анимаций.

Улучшение взаимодействия с пользователем: Рендеринг контента, который будет показан пользователю в будущем, позволяет создавать более отзывчивые интерфейсы. Например, загрузка следующей страницы в списке может быть выполнена заранее.

В React вы можете достичь "offscreen rendering" с помощью динамической загрузки компонентов, ленивой загрузки данных и рендеринга внутри невидимых контейнеров. На практике использование данной техники может зависеть от конкретных требований и сценариев вашего приложения.

# 7. Что заставляет сделать ререндер компонента?

Ререндер компонента в React происходит, когда происходят изменения в состоянии (state) или пропсах (props) компонента. React автоматически определяет, когда компонент должен быть перерисован, чтобы отразить изменения данных на пользовательском интерфейсе. Вот несколько основных факторов, которые могут вызвать ререндер компонента:

Изменение состояния (state): Если компонент использует внутреннее состояние с помощью хука useState (в функциональных компонентах) или методов this.setState (в классовых компонентах), изменение состояния вызовет перерисовку компонента.

Изменение пропсов (props): Когда компонент получает новые пропсы, он может быть перерисован для отображения этих новых данных.

Изменение контекста (context): Если компонент использует контекст (Context API), изменение данных в контексте может привести к перерисовке компонента и всех его потомков, которые зависят от этого контекста.

Изменение зависимостей в хуке useEffect: В функциональных компонентах, хук useEffect позволяет выполнить побочные эффекты, такие как запросы к серверу, при изменении определенных зависимостей. Если зависимости изменяются, компонент будет перерисован и useEffect будет вызван снова.

Изменение зависимостей в хуке useMemo или useCallback: Эти хуки позволяют оптимизировать вычисления или обработку данных, но компонент будет перерисован, если зависимости этих хуков изменятся.

Изменение пропсов или состояния родительского компонента: Если родительский компонент изменяет свои пропсы или состояние и передает их в дочерний компонент, дочерний компонент также будет перерисован.

Изменение времени: В некоторых случаях ререндер может быть вызван таймерами, анимациями или другими асинхронными операциями.

Изменение Redux-стейта или других состояний управляемых вне компонента: Если компонент использует глобальное состояние, например, с помощью библиотеки Redux, изменение этого состояния также может вызвать ререндер компонента.

Важно понимать, что React оптимизирует ререндеры и старается минимизировать количество перерисовок для улучшения производительности. Это достигается с помощью механизмов, таких как виртуальный DOM и сравнение изменений между старым и новым состоянием и пропсами.

# 8. Что такое неконтролируемые компоненты ?

Неконтролируемые компоненты (Uncontrolled Components) - это компоненты в React, значения которых не управляются напрямую через состояние компонента. Вместо этого, значения элементов формы (таких как input, select, textarea) в неконтролируемых компонентах управляются непосредственно DOM-элементами.

Это означает, что React не хранит и не обновляет значения элементов формы в состоянии компонента. Вместо этого, вы можете получить доступ к текущим значениям элементов формы через DOM-элементы напрямую, используя ссылки (refs) или другие методы. Этот подход полезен, когда вам не нужно управлять значениями элементов формы внутри React-компонента, и вы можете полагаться на DOM для этой функциональности.

Пример неконтролируемого компонента с использованием input:

```js
class UncontrolledComponent extends React.Component {
  inputRef = React.createRef();

  handleSubmit = (event) => {
    event.preventDefault();
    console.log("Submitted value:", this.inputRef.current.value);
  };

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <input type="text" ref={this.inputRef} />
        <button type="submit">Submit</button>
      </form>
    );
  }
}
```

В этом примере, значение поля ввода не хранится в состоянии компонента, а доступ к значению осуществляется напрямую через this.inputRef.current.value.

Неконтролируемые компоненты могут быть удобными в некоторых случаях, например, когда вам нужно работать с сторонними библиотеками, интегрировать React в существующий код или когда логика управления значениями лежит в DOM. Однако в большинстве случаев рекомендуется использовать контролируемые компоненты, где значения элементов формы хранятся в состоянии компонента и управляются через React.

# 9. Где в react в функциональном компоненте ты бы сделал обращение к API?

В функциональных компонентах в React лучшим местом для обращения к API является хук useEffect. useEffect позволяет выполнять побочные эффекты, такие как запросы к API, после того как компонент отрендерился на экране. Это обычно делается внутри функции-колбэка, переданной в useEffect.

Вот пример, как это может выглядеть:

```js
import React, { useState, useEffect } from "react";

function MyComponent() {
  const [data, setData] = useState([]);

  useEffect(() => {
    // Выполнение запроса к API
    fetch("https://api.example.com/data")
      .then((response) => response.json())
      .then((data) => setData(data))
      .catch((error) => console.error("Error fetching data:", error));
  }, []); // Пустой массив зависимостей - выполнится только после первого рендера

  return (
    <div>
      {data.map((item) => (
        <div key={item.id}>{item.name}</div>
      ))}
    </div>
  );
}
```

В этом примере, код для обращения к API находится внутри функции-колбэка, переданной в useEffect. Также заметьте, что второй аргумент useEffect - это массив зависимостей. Если вы оставите его пустым (как в примере), эффект выполнится только после первого рендера компонента. Если вам нужно выполнить эффект при изменении определенных значений, вы можете указать эти значения в массиве зависимостей.

Кроме useEffect, вы также можете использовать другие хуки, такие как useSWR, axios, или библиотеки для управления состоянием, такие как Redux, для более сложных сценариев работы с API.
