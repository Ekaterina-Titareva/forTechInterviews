<!-- ЗАДАЧА 1: -->

Дана целочисленная матрица matrix размера m x n. Если элемент равен 0, то установите все элементы в соответствующей строке и столбце в значение 0.

Вы должны выполнить это на месте.

Пример 1:

![image](./imgs/mat1.1.jpg)

**Вход:** matrix = [[1,1,1],[1,0,1],[1,1,1]]
**Выход:** [[1,0,1],[0,0,0],[1,0,1]]
Пример 2:

![image](./imgs/mat2.1.jpg)

**Вход:** matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
**Выход:** [[0,0,0,0],[0,4,5,0],[0,3,1,0]]
Ограничения:

m == matrix.length
n == matrix[0].length
1 <= m, n <= 200
-231 <= matrix[i][j] <= 231 - 1
Дополнительные вопросы:

Прямое решение с использованием пространства O(mn) вероятно не является хорошей идеей.
Простое улучшение использует пространство O(m + n), но всё равно не является лучшим решением.
Можете ли вы придумать решение с постоянным пространством?
Алгоритм 1
Данная задача заключается в том, чтобы пройти по матрице и каждый раз, когда мы встречаем элемент, равный нулю, устанавливать все элементы в соответствующей строке и столбце в значение ноль.

Одно из простых решений для этой задачи состоит в использовании дополнительного массива размером m x n, который будет использоваться для отметки строк и столбцов, в которых найдены нулевые элементы. Первый проход по матрице будет использоваться для отметки этих строк и столбцов в дополнительном массиве. Затем, второй проход по матрице будет использоваться для установки элементов в ноль в соответствующих строках и столбцах, отмеченных в дополнительном массиве.

Однако, это решение использует пространство O(m x n) для дополнительного массива, что может быть неэффективно.

Следующее улучшение заключается в том, чтобы использовать два дополнительных массива размером m и n, которые будут использоваться для отметки строк и столбцов. Первый проход по матрице будет использоваться для отметки этих строк и столбцов в соответствующих дополнительных массивах. Затем, второй проход по матрице будет использоваться для установки элементов в ноль в соответствующих строках и столбцах, отмеченных в дополнительных массивах.

Это решение использует пространство O(m + n) для дополнительных массивов, что уже лучше, но все еще не является лучшим решением.

Наилучшее решение для этой задачи может быть достигнуто, используя постоянное пространство. Мы можем использовать первую строку и первый столбец матрицы для отметки строк и столбцов, в которых найдены нулевые элементы. Сначала мы проверяем, есть ли нулевые элементы в первой строке или первом столбце и сохраняем это в двух дополнительных флагах - isFirstRowZero и isFirstColumnZero. Затем мы используем остальные строки и столбцы для отметки нулевых элементов. На следующем проходе по матрице мы устанавливаем все элементы в соответствующих строках и столбцах в ноль, кроме первой строки и первого столбца. Наконец, если флаги isFirstRowZero и isFirstColumnZero равны true, мы устанавливаем все элементы в первой строке и первом столбце в ноль.

Таким образом, мы можем решить данную задачу без использования дополнительного пространства, ограничиваясь только постоянным пространством.

/\*\*

- @param {number[][]} matrix
- @return {void} Do not return anything, modify matrix in-place instead.
  \*/
  var setZeroes = function(matrix) {
  const rows = matrix.length;
  const cols = matrix[0].length;

let firstRowHasZero = false;
let firstColHasZero = false;

// Check if there are zeros in the first row
for (let col = 0; col < cols; col++) {
if (matrix[0][col] === 0) {
firstRowHasZero = true;
break;
}
}

// Check if there are zeros in the first column
for (let row = 0; row < rows; row++) {
if (matrix[row][0] === 0) {
firstColHasZero = true;
break;
}
}

// Use first row and first column to mark if a row or column should be set to zero
for (let row = 1; row < rows; row++) {
for (let col = 1; col < cols; col++) {
if (matrix[row][col] === 0) {
matrix[row][0] = 0;
matrix[0][col] = 0;
}
}
}

// Set rows to zeros based on the first column
for (let row = 1; row < rows; row++) {
if (matrix[row][0] === 0) {
for (let col = 1; col < cols; col++) {
matrix[row][col] = 0;
}
}
}

// Set columns to zeros based on the first row
for (let col = 1; col < cols; col++) {
if (matrix[0][col] === 0) {
for (let row = 1; row < rows; row++) {
matrix[row][col] = 0;
}
}
}

// Set first row to zeros if necessary
if (firstRowHasZero) {
for (let col = 0; col < cols; col++) {
matrix[0][col] = 0;
}
}

// Set first column to zeros if necessary
if (firstColHasZero) {
for (let row = 0; row < rows; row++) {
matrix[row][0] = 0;
}
}
};

<!-- ЗАДАЧА 2: Удаление дубликатов из отсортированного массива  -->

Учитывая целочисленный массив nums, отсортированный в неубывающем порядке, удалите дубликаты на месте таким образом, чтобы каждый уникальный элемент появлялся только один раз. Относительный порядок элементов должен оставаться таким же. Затем верните количество уникальных элементов в nums.

Чтобы получить принятие, учитывайте количество уникальных элементов nums равным k и выполните следующие действия:

Измените массив nums так, чтобы первые k элементов массива nums содержали уникальные элементы в порядке их исходного появления в nums. Остальные элементы nums не являются важными, а также размер nums не имеет значения.
Верните k.
Пример 1:

**Вход:** nums = [1,1,2]
**Выход:** 2, nums = [1,2,_]
**Объяснение:** Ваша функция должна вернуть k = 2, с первыми двумя элементами nums равными 1 и 2 соответственно.
Не имеет значения, что остается за возвращаемым k (поэтому они обозначены подчеркиванием).
Пример 2:

**Вход:** nums = [0,0,1,1,1,2,2,3,3,4]
**Выход:** 5, nums = [0,1,2,3,4,_,_,_,_,_]
**Объяснение:** Ваша функция должна вернуть k = 5, с первыми пятью элементами nums равными 0, 1, 2, 3 и 4 соответственно.
Не имеет значения, что остается за возвращаемым k (поэтому они обозначены подчеркиванием).
Ограничения:

1 <= nums.length <= 3 \* 104
-100 <= nums[i] <= 100
nums отсортирован в неубывающем порядке.
Алгоритм 1
Для решения этой задачи можно использовать два указателя - один для обработки уникальных элементов и один для итерации по всем элементам массива.

Итерируясь по массиву, мы сравниваем текущий элемент nums[i] с предыдущим элементом nums[i-1]. Если они различаются, то мы увеличиваем счетчик уникальных элементов k и перезаписываем элемент nums[k] значением nums[i]. В результате, первые k элементов массива nums будут содержать уникальные элементы, а остальные будут не важны.

После обработки всех элементов массива, возвращаем значение k - количество уникальных элементов.

Пример для массива [0,0,1,1,1,2,2,3,3,4]:

Стартовое значение k равно 1, так как первый элемент всегда уникален.
При обработке второго элемента, nums[1]=0 равен предыдущему элементу nums[0]=0, поэтому этот элемент пропускается.
При обработке третьего элемента, nums[2]=1 не равен предыдущему элементу nums[1]=0, поэтому увеличиваем k до 2 и перезаписываем nums[2] значением nums[2]=1.
При обработке следующих трех элементов, nums[3], nums[4] и nums[5], значения равны предыдущему элементу, поэтому они пропускаются.
При обработке следующего элемента, nums[6]=2 не равен предыдущему элементу nums[5]=2, поэтому увеличиваем k до 3 и перезаписываем nums[3] значением nums[6]=2.
При обработке следующих двух элементов, nums[7] и nums[8], значения равны предыдущему элементу, поэтому они пропускаются.
При обработке последнего элемента, nums[9]=4 не равен предыдущему элементу nums[8]=3, поэтому увеличиваем k до 4 и перезаписываем nums[4] значением nums[9]=4.
В результате, для массива [0,0,1,1,1,2,2,3,3,4] значение k будет равно 5, а массив nums будет иметь вид [0,1,2,3,4,2,2,3,3,4].

var removeDuplicates = function(nums) {
let k = 0; // переменная для хранения количества уникальных элементов

    for (let i = 0; i < nums.length; i++) {
        if (i === 0 || nums[i] !== nums[i-1]) { // если текущий элемент отличается от предыдущего элемента (уникальный элемент)
            nums[k] = nums[i]; // перемещаем текущий элемент в начало массива
            k++; // увеличиваем счетчик уникальных элементов
        }
    }

    return k; // возвращаем количество уникальных элементов

};

<!-- ЗАДАЧА 3: Правильные скобочные последовательности  -->

Учитывая строку s, состоящую только из символов '(', ')', '{', '}', '[' и ']', определите, является ли входная строка допустимой.

Строка ввода считается допустимой, если:

Открытые скобки должны быть закрыты тем же типом скобок.
Открытые скобки должны быть закрыты в правильном порядке.
Каждой закрывающей скобке соответствует открывающая скобка того же типа.
Пример 1:

**Вход:** s = "()"
**Выход:** true
Пример 2:

**Вход:** s = "()[]{}"
**Выход:** true
Пример 3:

**Вход:** s = "(]"
**Выход:** false
Ограничения:

1 <= s.length <= 104
s состоит только из скобок '()[]{}'.
Алгоритм 1
Для решения этой задачи мы можем использовать стек.

Мы проходим по каждому символу в строке s. Если символ является открывающей скобкой ('(', '{', '['), мы добавляем его в стек. Если символ является закрывающей скобкой (')', '}', ']'), мы проверяем, соответствует ли закрывающая скобка последней открывающей скобке в стеке. Если они соответствуют, мы удаляем последнюю открывающую скобку из стека. Если они не соответствуют или стек пустой, то строка s не является допустимой и мы возвращаем false.

После того как мы проходим все символы в строке s, если стек пустой, то строка s является допустимой. Если стек не пустой, то строка s не является допустимой.

Таким образом, мы можем реализовать эту логику, используя стек и проходя по каждому символу в строке s. Если в итоге стек пустой, мы возвращаем true, в противном случае возвращаем false.

function isValid(s) {
const stack = [];
const openBrackets = ['(', '[', '{'];
const closedBrackets = [')', ']', '}'];

for (let i = 0; i < s.length; i++) {
// если текущий символ - открывающая скобка, добавляем ее в стек
if (openBrackets.includes(s[i])) {
stack.push(s[i]);
}
// если текущий символ - закрывающая скобка
else if (closedBrackets.includes(s[i])) {
// если стек пустой или верхний элемент стека не соответствует текущей закрывающей скобке,
// то строка недопустимая
if (stack.length === 0 || closedBrackets.indexOf(s[i]) !== openBrackets.indexOf(stack[stack.length - 1])) {
return false;
}
// если верхний элемент стека соответствует текущей закрывающей скобке, удаляем его из стека
stack.pop();
}
}

// проверяем, что все открывающие скобки были закрыты
return stack.length === 0;
}

<!-- ЗАДАЧА 4: Нахождение наибольшего общего префикса  -->

Напишите функцию для поиска наибольшей общей префиксной строки среди массива строк.

Если общего префикса нет, верните пустую строку "".

Пример 1:

**Ввод:** strs = ["flower","flow","flight"]
**Вывод:** "fl"

Пример 2:

**Ввод:** strs = ["dog","racecar","car"]
**Вывод:** ""
**Пояснение:** Среди входных строк нет общего префикса.

Ограничения:

1 <= strs.length <= 200
0 <= strs[i].length <= 200
strs[i] состоит только из строчных английских букв.
Алгоритм
Шаги алгоритма:

Проверяем, не является ли массив строк пустым. Если да, то сразу возвращаем пустую строку.
Инициализируем переменную prefix начальным значением, равным первой строке из массива.
Начинаем итерацию по остальным строкам в массиве, начиная с индекса 1.
Внутри цикла проверяем, начинается ли текущая строка с текущего значения префикса. Если нет, то переходим к шагу 5.
В этом шаге укорачиваем префикс на один символ справа и проверяем, не стал ли он пустой. Если префикс стал пустой строкой, значит, нет общего префикса, и мы возвращаем пустую строку.
По завершении цикла возвращаем оставшийся префикс, который будет наибольшим общим префиксом для всех строк массива.
Такой алгоритм гарантирует нахождение наибольшего общего префикса среди заданного массива строк.

function longestCommonPrefix(strs) {
// Шаг 1: Проверка на пустой массив строк
if (strs.length === 0) {
return "";
}

    // Шаг 2: Инициализация начального префикса первой строкой из массива
    let prefix = strs[0];

    // Шаг 3: Итерация по остальным строкам массива
    for (let i = 1; i < strs.length; i++) {
        // Шаг 4: Пока текущая строка не начинается с текущего префикса
        while (strs[i].indexOf(prefix) !== 0) {
            // Укорачиваем префикс на один символ
            prefix = prefix.slice(0, prefix.length - 1);

            // Шаг 5: Проверка на пустой префикс
            if (prefix === "") {
                return "";
            }
        }
    }

    // Шаг 6: Возврат наибольшего общего префикса
    return prefix;

}

// Примеры использования:
const strs1 = ["flower","flow","flight"];
console.log(longestCommonPrefix(strs1)); // Вывод: "fl"

const strs2 = ["dog","racecar","car"];
console.log(longestCommonPrefix(strs2)); // Вывод: ""

<!-- ЗАДАЧА 5: Две суммы  -->

Дан массив целых чисел nums и целое число target. Вернуть индексы двух чисел таких, что их сумма равна target.

Вы можете предположить, что у каждого ввода ровно одно решение, и вы не можете использовать один элемент дважды.

Вы можете вернуть ответ в любом порядке.

Примеры
Пример 1:

**Вход:** nums = [2,7,11,15], target = 9
**Вывод:** [0,1]
**Объяснение:** Поскольку nums[0] + nums[1] == 9, мы возвращаем [0, 1].
Пример 2:

**Вход:** nums = [3,2,4], target = 6
**Вывод:** [1,2]
Пример 3:

**Вход:** nums = [3,3], target = 6
**Вывод:** [0,1]
Ограничения
2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
Существует только один правильный ответ.
Фоллоу-ап
Можете ли вы разработать алгоритм с временной сложностью O(n2)?

Алгоритм 1
Алгоритм

Подход грубой силы прост. Пройдитесь по каждому элементу xxx и найдите значение, которое равно разности между целью и xxx (target−xtarget - xtarget−x).

Реализация

twoSum(nums, target) {
for (let i = 0; i < nums.length; i++) {
for (let j = i + 1; j < nums.length; j++) {
if (nums[j] === target - nums[i]) {
return [i, j];
}
}
}
return null;
}
Анализ сложности

Временная сложность: O(n2).
Для каждого элемента мы пытаемся найти его комлемент, перебирая остальной массив, что занимает O(n) времени. Следовательно, временная сложность равна O(n2).

Пространственная сложность: O(1).
Затрачиваемое пространство не зависит от размера входного массива, поэтому используется только константное пространство.

Алгоритм 2
Оказывается, мы можем сделать это за один проход. Во время итерации и вставки элементов в хеш-таблицу мы также проверяем, существует ли уже комплимент текущего элемента в хеш-таблице. Если он существует, мы нашли решение и сразу возвращаем индексы.

Реализация

twoSum(nums, target) {
let map = new Map();
for (let i = 0; i < nums.length; i++) {
let complement = target - nums[i];
if (map.has(complement)) {
return [map.get(complement), i];
}
map.set(nums[i], i);
}
return null;
}

Анализ сложности

Временная сложность: O(n).
Мы проходимся по списку, содержащему n элементов, только один раз. Каждая проверка в таблице занимает только O(1) времени.

Пространственная сложность: O(n).
Дополнительное пространство, необходимое, зависит от количества элементов, хранящихся в хеш-таблице, которая хранит не более n элементов.
