<!-- 1. Для чего используется Key -->

key - это специальный атрибут, который используется в React при рендеринге списков компонентов, чтобы помочь React оптимизировать процесс обновления и перерисовки элементов списка.

Когда вы отображаете массив элементов (например, через метод map) внутри компонента, React использует значения key для отслеживания, какие элементы были добавлены, изменены или удалены. Ключи помогают React сравнивать элементы списка между рендерами и эффективно обновлять только те элементы, которые изменились.

Важные моменты:

Уникальность: Ключи должны быть уникальными в пределах списка. Каждый ключ должен отличаться от других ключей в этом списке, чтобы React мог корректно сопоставить элементы между рендерами.

Стабильность: Ключи не должны меняться между рендерами, иначе React может считать элемент новым при каждом рендере, что может привести к неэффективности.

Пример использования key:

function ListItem({ item }) {
return <li key={item.id}>{item.name}</li>;
}

function List({ items }) {
return (

<ul>
{items.map(item => (
<ListItem key={item.id} item={item} />
))}
</ul>
);
}
В этом примере, каждый элемент списка получает уникальный ключ item.id. Если элементы в массиве изменятся или будут пересортированы, React сможет эффективно обновить только изменившиеся элементы в DOM.

Без использования ключей, React может столкнуться с проблемами при обновлении списка, что может привести к непредсказуемому поведению и плохой производительности.

<!-- 2. Для чего нужны state и props в React? -->

В React state и props используются для управления и передачи данных между компонентами.

state: state представляет собой объект, содержащий данные, которые могут изменяться внутри компонента. Когда state изменяется, React перерисовывает компонент и обновляет соответствующие элементы интерфейса. state является локальным для компонента и управляется самим компонентом. Он может быть инициализирован в конструкторе компонента и изменен с помощью метода setState(). Пример использования state:

import React, { Component } from 'react';

class Counter extends Component {
constructor(props) {
super(props);
this.state = {
count: 0
};
}

incrementCount() {
this.setState({ count: this.state.count + 1 });
}

render() {
return (

<div>
<p>Count: {this.state.count}</p>
<button onClick={() => this.incrementCount()}>Increment</button>
</div>
);
}
}
В этом примере компонент Counter имеет внутреннее состояние count, которое увеличивается при нажатии кнопки "Increment". При изменении состояния с помощью setState(), React обновляет компонент и обновляет отображение счетчика на странице.

props: props (сокращение от "properties") представляют собой значения, передаваемые компоненту из его родительского компонента. props являются неизменяемыми и служат для передачи данных и настроек в компоненты. Родительский компонент передает props дочернему компоненту, и дочерний компонент может использовать эти значения в своей реализации. Пример использования props:

import React from 'react';

function Greeting(props) {
return <p>Hello, {props.name}!</p>;
}

function App() {
return <Greeting name="John" />;
}
В этом примере компонент App передает name со значением "John" компоненту Greeting через props. Компонент Greeting отображает приветствие с использованием переданного имени.

Использование state и props позволяет компонентам React быть динамическими и взаимодействовать друг с другом, передавая и обновляя данные. state используется для управления локальными данными внутри компонента, в то время как props используются для передачи данных от родительского компонента к дочерним компонентам.

<!-- 3. Расскажи про контекст в React -->

Контекст (Context) в React представляет собой механизм, который позволяет передавать данные через иерархию компонентов без явной передачи пропсов (props) от родительских компонентов к дочерним. Контекст позволяет компонентам получать доступ к данным, которые находятся на более высоком уровне иерархии, без необходимости передавать эти данные через каждый промежуточный компонент.

Контекст особенно полезен, когда несколько компонентов в иерархии нуждаются в доступе к одним и тем же данным. Вместо того чтобы передавать эти данные через несколько уровней компонентов с помощью пропсов, контекст позволяет установить "поставщика" контекста на верхнем уровне иерархии, а затем "потребителям" контекста получать данные из этого контекста в любом месте вниз по иерархии.

В React контекст реализуется с помощью двух основных компонентов: Provider (поставщик) и Consumer (потребитель).

Provider: Компонент, который устанавливает контекст и предоставляет данные для него. Оборачивая родительские компоненты в Provider, мы делаем контекст и его данные доступными для всех дочерних компонентов в иерархии.

Consumer: Компонент, который использует контекст и получает данные из него. Оборачивая компонент в Consumer, мы можем получить доступ к данным контекста и использовать их внутри компонента.

Пример использования контекста в React:

// Создаем контекст
const MyContext = React.createContext();

// Компонент-поставщик
class MyProvider extends React.Component {
state = {
data: 'Some data'
};

render() {
return (
<MyContext.Provider value={this.state.data}>
{this.props.children}
</MyContext.Provider>
);
}
}

// Компонент-потребитель
class MyConsumer extends React.Component {
render() {
return (
<MyContext.Consumer>
{data => <div>Data from context: {data}</div>}
</MyContext.Consumer>
);
}
}

// Использование компонентов
class App extends React.Component {
render() {
return (
<MyProvider>

<div>
<h1>My App</h1>
<MyConsumer />
</div>
</MyProvider>
);
}
}

ReactDOM.render(<App />, document.getElementById('root'));
В этом примере мы создаем контекст MyContext с помощью React.createContext(). Затем у нас есть компонент-поставщик MyProvider, который устанавливает значение контекста (state.data) с помощью <MyContext.Provider>. Вложенный компонент MyConsumer оборачивается в <MyContext.Consumer>, чтобы получить значение контекста и использовать его внутри компонента.

В компоненте App мы оборачиваем иерархию компонентов в , чтобы сделать контекст и данные доступными для компонентов ниже по иерархии. В компоненте MyConsumer мы выводим данные из контекста внутри < div>.

Таким образом, использование контекста позволяет передавать данные между компонентами, не пропуская их через каждый компонент в иерархии. Это удобно, когда несколько компонентов нуждаются в доступе к одним и тем же данным, и упрощает управление состоянием и передачу данных в React приложениях.

<!-- 4. Ref и key, что это? -->

Ключ (Key) в React — специальный строковый атрибут, который необходимо включать при создании списков элементов.

Ключи помогают React идентифицировать, какие элементы были изменены, добавлены или удалены. Ключи должны быть заданы элементам внутри массива, чтобы предоставить элементам постоянный идентификатор.

Пример:

const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =>

  <li key={number.toString()}>
    {number}
  </li>
);
Если у вас нет постоянных идентификаторов для отрисовываемых элементов, в крайнем случае вы можете использовать индекс элемента в качестве ключа

Если явный ключ для списка элементов не назначен, тогда React по умолчанию будет использовать индексы в качестве ключей. Не рекомендуется использовать индексы для ключей, если порядок элементов может измениться.

Ключи имеют смысл только в контексте окружающего массива. Например, если вы выделяете компонент ListItem, вам нужно присваивать ключ элементам <ListItem /> в массиве, а не элементам <li> в самом ListItem.

Пример:

function ListItem(props) {
const value = props.value;
return (
// Неправильно! Здесь не нужно указывать ключ:

<li key={value.toString()}>
{value}
</li>
);
}

function NumberList(props) {
const numbers = props.numbers;
const listItems = numbers.map((number) =>
// Неправильно! Здесь должен быть указан ключ:
<ListItem value={number} />
);
return (

<ul>
{listItems}
</ul>
);
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
<NumberList numbers={numbers} />,
document.getElementById('root')
);
Refs (ссылки) предоставляют способ доступа к DOM-узлам или React-элементам, созданным в методе render().

Есть несколько хороших примеров использования ссылок:

Управление фокусом, выделение текста или воспроизведение медиаресурсами.
Выполнение анимаций в императивном подходе.
Интеграция со сторонними библиотеками, взаимодействующие с DOM.
Ссылки создаются с использованием React.createRef() и добавляются к React-элементам с помощью атрибута ref. Ссылки обычно присваиваются свойству экземпляра, когда компонент создаётся таким образом, чтобы на них можно было ссылаться по всему компоненту.

class MyComponent extends React.Component {
constructor(props) {
super(props);
this.myRef = React.createRef();
}
render() {
return <div ref={this.myRef} />;
}
}
Когда ссылка передаётся элементу в render(), доступ к её узлу можно получить в атрибуте current.

Когда атрибут ref используется в HTML-элементе, ref, созданный в конструкторе с помощью React.createRef(), получает базовый элемент DOM в качестве своего свойства current.
Когда атрибут ref используется на пользовательском классовом компоненте, объектref получает примонтированный экземпляр компонента в качестве своего свойства current.
Вы не можете использовать атрибут ref в функциональных компонентах, потому что у них не может быть экземпляров. Однако вы можете использовать атрибут ref внутри функционального компонента, если вы ссылаетесь на DOM-элемент или классовый компонент.

<!-- 5. Почему не использовать встроенный контекст? -->

Встроенный контекст в React представлен API, который позволяет передавать данные через компонентное дерево без явной передачи пропсов между каждым компонентом. Однако, хотя встроенный контекст может быть полезным в некоторых сценариях, есть несколько причин, почему его использование может быть ограничено или не рекомендуется:

Сложность чтения и отладки: Использование контекста может сделать код менее читаемым и сложным для понимания, так как данные передаются неявно через компонентное дерево. Это может усложнить отладку, особенно при комплексных компонентных структурах.

Затруднение в тестировании: При использовании контекста, необходимо обеспечивать наличие правильных значений контекста при тестировании компонентов. Это может усложнить тестирование и создание изолированных тестовых сценариев.

Сценарии ограниченного применения: Встроенный контекст не является идеальным для всех сценариев. Он хорошо подходит для передачи данных, которые действительно являются "глобальными" для приложения. В случае, если вам нужно передавать данные между компонентами на более низком уровне и эти данные не считаются глобальными, использование пропсов или других управляемых средств передачи данных может быть предпочтительнее.

Поддержка и обратная совместимость: API встроенного контекста может меняться в будущих версиях React. Это может привести к проблемам с обратной совместимостью и требовать пересмотра кода при обновлении.

Вместо использования встроенного контекста, иногда рекомендуется использовать управляемый пропсами способ передачи данных или более специфичные для сценария решения, такие как Redux для управления состоянием или библиотеки для управления темами/стилями. Но как и с любой технологией, выбор зависит от конкретных требований и архитектуры вашего приложения.

<!-- 6. Как передать данные из дочернего в родительский -->

Для передачи данных из дочернего компонента в родительский компонент в React можно использовать пропсы (props).

Пропсы - это свойства, которые передаются из родительского компонента в дочерний компонент. Дочерний компонент может использовать эти пропсы для отображения данных или выполнения действий.
Например, если у вас есть родительский компонент ParentComponent и дочерний компонент ChildComponent , и вы хотите передать данные из ChildComponent в ParentComponent , вы можете сделать следующее:

В ChildComponent определите функцию, которая будет вызываться при изменении данных. Например:

function handleDataChange(data) {
// Обновите состояние компонента
this.setState({ data });
// Отправьте событие на родительский компонент
this.props.onDataChange(data);
}
В ChildComponent передайте функцию handleDataChange в качестве пропса onDataChange :

<ChildComponent onDataChange={handleDataChange} />
В ParentComponent определите функцию, которая будет вызываться при изменении данных в ChildComponent . Например:

function handleDataChange(data) {
// Обновите состояние компонента ParentComponent
this.setState({ childData: data });
}
В ParentComponent передайте функцию handleDataChange в качестве обработчика события onDataChange из ChildComponent :

<ChildComponent onDataChange={handleDataChange.bind(this)} />
Теперь при изменении данных в ChildComponent функция handleDataChange будет вызываться, которая отправит событие на ParentComponent с обновленными данными. В ParentComponent вы можете определить функцию handleDataChange , которая будет обновлять состояние компонента ParentComponent с помощью новых данных.

<!-- 7. Что такое React.Context? -->

React.Context - это механизм, предоставляемый библиотекой React, для передачи данных вниз по иерархии компонентов без явной передачи пропсов через промежуточные компоненты. Он позволяет создавать глобальные переменные, доступные для чтения и записи из разных компонентов приложения.

React.Context состоит из двух основных компонентов:

Context Provider (поставщик контекста): Компонент, который определяет контекст и предоставляет данные. Он оборачивает дерево компонентов, которым требуется доступ к этим данным. Context Provider обычно создается с использованием createContext функции из библиотеки React.

Context Consumer (потребитель контекста): Компонент, который использует контекст и получает доступ к данным, предоставленным Context Provider. Он может быть размещен в любом месте дерева компонентов, вложенном в Context Provider. Context Consumer используется для чтения данных из контекста и реагирования на их изменения.

Использование React.Context позволяет избежать "прокидывания пропсов" через несколько промежуточных компонентов, особенно в случаях, когда данные нужны во множестве компонентов на разных уровнях иерархии. Он также облегчает обновление контекста и обработку изменений данных в приложении.

Пример использования React.Context:

// Создание контекста
const MyContext = React.createContext();

// Компонент-поставщик контекста
const MyContextProvider = ({ children }) => {
const data = "Здесь находятся данные контекста";

return (
<MyContext.Provider value={data}>
{children}
</MyContext.Provider>
);
};

// Компонент-потребитель контекста
const MyComponent = () => {
return (
<MyContext.Consumer>
{(data) => <p>{data}</p>}
</MyContext.Consumer>
);
};

// Использование контекста
const App = () => {
return (
<MyContextProvider>
<MyComponent />
</MyContextProvider>
);
};
В этом примере MyContextProvider определяет контекст и предоставляет данные "Здесь находятся данные контекста". Компонент MyComponent читает эти данные из контекста и отображает их. App является верхнеуровневым компонентом, содержащим MyContextProvider и MyComponent, и обеспечивает доступ к контексту для MyComponent.

<!-- 8. Что такое Prop drilling -->

Prop drilling - это процесс в React, который заключается в передаче пропсов через цепочку компонентов, чтобы достичь нужного состояния.

Когда вы хотите изменить состояние компонента, вы передаете его в качестве пропса в родительский компонент, а затем этот пропс передается дальше по цепочке компонентов до тех пор, пока не будет достигнут компонент, который может изменить его состояние. Этот процесс называется "prop drilling".

Например, если у вас есть компонент "ChildComponent", который должен изменить состояние компонента "ParentComponent", вы можете передать функцию обратного вызова в качестве пропса из "ChildComponent" в "ParentComponent". Затем вы можете вызвать эту функцию обратного вызова в "ChildComponent", чтобы изменить состояние "ParentComponent".

function ParentComponent() {
const [count, setCount] = useState(0);

return (

<div>
<p>Count: {count}</p>
<ChildComponent setCount={setCount} />
</div>
);
}

function ChildComponent(props) {
const handleClick = () => {
props.setCount(count + 1);
};

return (

<div>
<button onClick={handleClick}>Increment</button>
</div>
);
}
В этом примере мы передаем функцию обратного вызова "setCount" в качестве пропса из "ChildComponent" в "ParentComponent". Затем мы вызываем эту функцию обратного вызова в "ChildComponent", чтобы изменить состояние "ParentComponent".

<!-- 9. Что будет если мы мутируем стейт, вместо того, чтобы выдавать новый объект? -->

Мутация стейта (state mutation) может привести к нежелательным побочным эффектам, таким как неожиданное изменение других частей приложения или ошибки в работе приложения. Кроме того, мутации могут быть трудными для отладки и тестирования, так как они могут быть сложными для восстановления после ошибок.

Вместо того, чтобы мутировать стейт, лучше использовать оптимистическое обновление (optimistic update), которое позволяет клиенту предсказывать, какие изменения ожидаются в стейте, прежде чем они внесены на сервер. Это позволяет уменьшить количество ошибок и упростить отладку.

Однако, если вы все же решите мутировать стейт, необходимо быть осторожным и убедиться, что вы не приводите к неожиданным побочным эффектам. Например, вы можете использовать ключи объектов, чтобы отслеживать изменения в стейте и обновлять только те части, которые изменились. Также необходимо убедиться, что вы не изменяете объекты, которые могут быть использованы другими частями приложения.

<!-- 10. Является ли верным такое использование свойства (prop) key: -->

interface IItem {
name: string;
};
const MyList: FC = (props: { items: IItem[] }) => {
return (

<ul>
{props.items.map((item: IItem) => (
<li key={item.name}>{item.name}</li>
))}
</ul>
);
}
Да, это верное использование свойства key в компоненте React.

Свойство key используется для идентификации элементов в списке и для оптимизации производительности React. Когда компонент перерисовывается, React использует свойство key для определения, какие элементы должны быть добавлены, изменены или удалены.

В данном случае, свойство key используется для идентификации элементов списка по имени. Каждый элемент списка имеет уникальное имя, которое используется в свойстве key. Это позволяет React понимать, какие элементы нужно изменить или удалить при обновлении компонента, и оптимизировать производительность.

11. Является ли верным такое использование свойства (prop) key:

interface IItem {
name: string;
};
const MyList: FC = (props: { items: IItem[] }) => {
return (

<ul>
{props.items.map((item: IItem) => (
<li key={item.name}>{item.name}</li>
))}
</ul>
);
}
Да, это верное использование свойства key в компоненте React.

Свойство key используется для идентификации элементов в списке и для оптимизации производительности React. Когда компонент перерисовывается, React использует свойство key для определения, какие элементы должны быть добавлены, изменены или удалены.

В данном случае, свойство key используется для идентификации элементов списка по имени. Каждый элемент списка имеет уникальное имя, которое используется в свойстве key. Это позволяет React понимать, какие элементы нужно изменить или удалить при обновлении компонента, и оптимизировать производительность.

<!-- 11. Как взаимодействовать с элементом через React, если требуется обратиться к нему? -->

В React для взаимодействия с элементами используется подход, основанный на создании ссылок (refs). Чтобы обратиться к элементу и работать с ним, можно использовать ref для его определения.

Пример:

import React, { useRef } from 'react';

function MyComponent() {
// Создаем ref
const myElementRef = useRef(null);

// Функция, которая будет вызвана после монтирования компонента
const handleMount = () => {
// Здесь можно обращаться к элементу через ref
if (myElementRef.current) {
// Доступ к DOM-элементу происходит через .current
myElementRef.current.style.backgroundColor = 'red';
}
};

return (

<div>
{/_ Привязываем ref к элементу _/}
<div ref={myElementRef}>Это элемент, с которым нужно взаимодействовать</div>
<button onClick={handleMount}>Нажать для обращения к элементу</button>
</div>
);
}
В этом примере мы создаем ref с помощью useRef, затем привязываем его к DOM-элементу <div> с помощью ref={myElementRef}. Когда пользователь нажимает на кнопку, вызывается функция handleMount, в которой мы обращаемся к элементу через myElementRef.current и, например, меняем его стиль. Это позволяет нам взаимодействовать с элементами напрямую в React-приложениях.

<!-- 12. Как взаимодействовать с элементом через React, если требуется обратиться к нему? -->

В React для взаимодействия с элементами используется подход, основанный на создании ссылок (refs). Чтобы обратиться к элементу и работать с ним, можно использовать ref для его определения.

Пример:

import React, { useRef } from 'react';

function MyComponent() {
// Создаем ref
const myElementRef = useRef(null);

// Функция, которая будет вызвана после монтирования компонента
const handleMount = () => {
// Здесь можно обращаться к элементу через ref
if (myElementRef.current) {
// Доступ к DOM-элементу происходит через .current
myElementRef.current.style.backgroundColor = 'red';
}
};

return (
<div>
{/_ Привязываем ref к элементу _/}
<div ref={myElementRef}>Это элемент, с которым нужно взаимодействовать</div>
<button onClick={handleMount}>Нажать для обращения к элементу</button>
</div>
);
}
В этом примере мы создаем ref с помощью useRef, затем привязываем его к DOM-элементу <div> с помощью ref={myElementRef}. Когда пользователь нажимает на кнопку, вызывается функция handleMount, в которой мы обращаемся к элементу через myElementRef.current и, например, меняем его стиль. Это позволяет нам взаимодействовать с элементами напрямую в React-приложениях.

13.
