# React Hooks 

# 1. Что представляют собой хуки в React, а также ключевые хуки и их возможности? 

Хуки (hooks) в React - это новое API, представленное в React 16.8, которое позволяет функциональным компонентам использовать состояние (state) и другие возможности, ранее доступные только классовым компонентам

Хуки предоставляют специальные функции, называемые ключевыми хуками (built-in hooks), которые могут быть вызваны внутри функционального компонента для получения и использования определенных возможностей React.

Некоторые из ключевых хуков в React:

useState: Хук useState позволяет функциональному компоненту использовать состояние (state). Он возвращает пару значений - текущее состояние и функцию для его обновления. Пример использования:
```js
import React, { useState } from 'react';

function Counter() {
const [count, setCount] = useState(0);

const increment = () => {
setCount(count + 1);
};

return (

<div>
<p>Count: {count}</p>
<button onClick={increment}>Increment</button>
</div>
);
}
```
useEffect: Хук useEffect позволяет функциональному компоненту выполнять побочные эффекты, такие как выполнение запросов к API, подписка на события, изменение заголовка страницы и т. д. Он принимает функцию-эффект и, опционально, массив зависимостей, которые указывают, при изменении каких значений должен быть повторно вызван эффект. Пример использования:
```js
import React, { useEffect, useState } from 'react';

function MyComponent() {
const [data, setData] = useState(null);

useEffect(() => {
fetchData();
}, []);

const fetchData = async () => {
const response = await fetch('https://api.example.com/data');
const data = await response.json();
setData(data);
};

return <div>{data ? <p>Data: {data}</p> : <p>Loading...</p>}</div>;
}
```
useContext: Хук useContext позволяет функциональному компоненту получить значение контекста, определенного в верхних компонентах и переданного с помощью Context.Provider. Он принимает объект контекста и возвращает текущее значение контекста. Пример использования: javascript
```js
import React, { useContext } from 'react';
import MyContext from './MyContext';

function MyComponent() {
const contextValue = useContext(MyContext);

return <div>{contextValue}</div>;
}
```
Кроме этих ключевых хуков, в React также есть другие встроенные хуки, такие как useReducer для управления сложным состоянием, useCallback для оптимизации колбэк-функций, useMemo для оптимизации вычислений, useRef для получения ссылок на DOM-элемент и другие хуки, предоставляющие различные возможности.

Хуки в React позволяют функциональным компонентам иметь собственное состояние, работать с побочными эффектами, использовать контекст и другие возможности, которые ранее были доступны только классовым компонентам. Они упрощают разработку и повышают читаемость кода, делая его более декларативным и компактным. Хуки также способствуют повторному использованию кода и обеспечивают более гибкую и масштабируемую архитектуру приложений на React.

# 2. Назовите некоторые правила использования хуков. 

Да, есть несколько правил, которые следует соблюдать при использовании хуков в React:

Используйте хуки только в функциональных компонентах. Хуки не могут быть использованы в классовых компонентах.

Избегайте использования хуков внутри других хуков. Например, с осторожностью используйте хук useState внутри хука useEffect, чтобы не вызвать бесконечный цикл.

Используйте хуки только в тех местах, где это необходимо. Например, не используйте хук useCallback для оборачивания каждой функции

Используйте хуки с умеренностью. Не используйте большое количество хуков в одном компоненте, чтобы избежать ухудшения производительности.

Используйте хуки правильно. Например, используйте хук useMemo для кэширования значений, а не хук useCallback.

Тестируйте свой код. Используйте тесты для проверки корректности работы вашего кода и избежания ошибок.

Обновляйте свой код. Используйте новые версии библиотек и фреймворков, чтобы получить доступ к новым хукам и функциям.

#  3. Для чего нужен useCallback? 

useCallback - это хук в React, который позволяет оптимизировать производительность компонентов путем кеширования колбэк-функций.

Когда функциональный компонент перерендеривается, все переменные и функции внутри компонента создаются заново. Это может привести к ненужным перерисовкам дочерних компонентов, особенно если эти компоненты принимают колбэк-функции в качестве пропсов.

useCallback решает эту проблему, сохраняя колбэк-функцию между рендерами компонента, если ее зависимости не изменились. Таким образом, при повторном рендеринге компонента будет использоваться одна и та же функция, а не создаваться новая. Это позволяет избежать ненужных перерисовок дочерних компонентов, которые принимают эти колбэк-функции.

Пример использования useCallback:
```js
import React, { useCallback } from 'react';

function ParentComponent() {
const handleClick = useCallback(() => {
// Логика обработки клика
console.log('Button clicked');
}, []);

return <ChildComponent onClick={handleClick} />;
}

function ChildComponent({ onClick }) {
// Рендеринг дочернего компонента
return <button onClick={onClick}>Click me</button>;
}
```
В этом примере handleClick будет кеширована с помощью useCallback. При каждом рендере ParentComponent будет использоваться одна и та же функция handleClick, если ее зависимости (в данном случае, пустой массив зависимостей) не изменились. Это позволяет передавать стабильные колбэк-функции в дочерние компоненты, минимизируя перерисовки этих компонентов при обновлении родительского компонента.

Важно отметить, что использование useCallback не всегда является необходимым и должно основываться на профилировании и оптимизации производительности приложения. Он наиболее полезен в случаях, когда компонент имеет сложные структуры и много дочерних компонентов, и требуется предотвратить ненужные перерисовки этих дочерних компонентов при обновлении родительского компонента.

# 4. Каким образом будет осуществляться процесс рендеринга дочерних компонентов, передаваемых через map, с использованием useCallback из родительского компонента? 

В React процесс рендеринга дочерних компонентов, которые возвращает метод map, может быть оптимизирован с использованием useCallback в родительском компоненте. useCallback позволяет сохранить ссылку на колбэк-функцию и повторно использовать ее при повторном рендеринге родительского компонента. Это особенно полезно, когда дочерние компоненты используют эту функцию в качестве пропса, чтобы избежать ненужных повторных рендеров дочерних компонентов.

Вот пример кода, демонстрирующий этот процесс:
```js
import React, { useCallback } from 'react';

function ParentComponent() {
const items = ['item 1', 'item 2', 'item 3'];

const handleClick = useCallback((item) => {
console.log('Clicked:', item);
}, []);

return (

<div>
{items.map((item) => (
<ChildComponent key={item} item={item} onClick={handleClick} />
))}
</div>
);
}

function ChildComponent({ item, onClick }) {
console.log('Rendering:', item);
return <button onClick={() => onClick(item)}>Click me</button>;
}
```
В этом примере handleClick обернут в useCallback, и передается в дочерний компонент ChildComponent через пропс onClick. Таким образом, при повторном рендеринге ParentComponent, колбэк-функция handleClick будет повторно использоваться, и дочерние компоненты не будут перерисовываться, если пропсы, переданные им, не изменились.

Использование useCallback особенно полезно, когда родительский компонент имеет большое количество дочерних компонентов или когда функция требует значительных вычислительных затрат.

# 5. useMemo и useCallback, в чем их разница? 

useMemo и useCallback - это два хука в React, которые используются для оптимизации производительности компонентов путем кэширования результатов вычислений. Они работают похожим образом, но есть разница в том, для чего они предназначены.

Хук useMemo используется для кэширования и возврата мемоизированного значения. Он принимает два аргумента: функцию-вычислитель и зависимости. Функция-вычислитель выполняется только в том случае, если какая-либо из зависимостей изменилась. Если зависимости остаются неизменными, useMemo возвращает закэшированное значение, избегая повторного вычисления. Это особенно полезно, когда вычисление значения является ресурсоемкой операцией.

Вот пример использования useMemo:
```js
const memoizedValue = useMemo(() =>
computeExpensiveValue(a, b), [a, b]);
```
В этом примере computeExpensiveValue - это функция, которая выполняет сложные вычисления. Если значения a или b изменятся, useMemo выполнит computeExpensiveValue и вернет новое значение. В противном случае будет возвращено закэшированное значение.

Хук useCallback, с другой стороны, используется для кэширования функции. Он принимает два аргумента: функцию и массив зависимостей. Он возвращает мемоизированную версию функции, которая будет сохраняться между рендерами. Если какая-либо из зависимостей изменится, useCallback вернет новую функцию.

Вот пример использования useCallback:
```js
const memoizedCallback = useCallback(() => {
doSomething(a, b);
}, [a, b]);
```
В этом примере doSomething - это функция, которую вы хотите кэшировать. Если значения a или b изменятся, useCallback вернет новую функцию. В противном случае будет возвращена закэшированная функция.

Таким образом, разница между useMemo и useCallback заключается в том, что useMemo кэширует результат вычисления, тогда как useCallback кэширует саму функцию. Используйте useMemo, если вам нужно кэшировать результат вычисления, и useCallback, если вам нужно кэшировать функцию.

# 6.Чем отличается useMemo от React.memo? 

useMemo и React.memo - это две разные вещи, которые используются для оптимизации производительности компонентов React.

useMemo - это хук, который позволяет вычислять значение только при изменении зависимостей. Он принимает функцию вычисления значения и массив зависимостей. Если зависимости не изменились, то функция вычисления значения не будет вызвана повторно. Вместо этого, результат предыдущего вызова будет возвращен.

React.memo - это компонент высшего порядка (HOC), который позволяет оптимизировать рендеринг компонентов. Он принимает компонент, который нужно оптимизировать, и массив зависимостей. Если зависимости не изменились, то компонент не будет перерендериваться. Вместо этого, результат предыдущего рендеринга будет использован.

Основное отличие между useMemo и React.memo заключается в том, что useMemo вычисляет значение при изменении зависимостей, а React.memo оптимизирует рендеринг компонентов. Если вы хотите оптимизировать рендеринг компонентов, то React.memo может быть полезным. Если же вы хотите вычислять значение только при изменении зависимостей, то useMemo может быть более эффективным.

# 7. Что передается вторым аргументом в React.memo? 

В React функция React.memo() используется для оптимизации производительности компонентов путем предотвращения ненужного повторного рендеринга. Эта функция создает мемоизированную версию компонента, которая будет повторно рендериться только при изменении пропсов.

Второй аргумент в функции React.memo() - это функция сравнения (также называемая "компаратором"). Эта функция определяет, должны ли новые пропсы считаться равными предыдущим пропсам, чтобы компонент не перерисовывался.

Сравнение пропсов в React.memo() происходит следующим образом:

Если второй аргумент не указан, React.memo() будет использовать поверхностное сравнение пропсов. Это означает, что он будет сравнивать ссылки на объекты и значения примитивов. Если ссылки или значения равны, компонент не будет перерисован.
Если второй аргумент - это функция сравнения, то при каждом рендере React будет вызывать эту функцию, передавая текущие пропсы и предыдущие пропсы. Если функция вернет true, компонент не будет перерисован.
Пример использования React.memo() с функцией сравнения:
```js
import React from 'react';

const MyComponent = React.memo((props) => {
// Компонентов не будет перерисовываться,
// если пропсы равны по значению свойств "a" и "b"
}, (prevProps, nextProps) => {
return prevProps.a === nextProps.a && prevProps.b === nextProps.b;
});
```
Таким образом, второй аргумент в React.memo() позволяет более точно контролировать, когда компонент должен быть перерисован на основе изменений пропсов.

# 8. Расскажите о хуках useRef и useState. 

useState - это хук, который позволяет функциональным компонентам React добавлять внутреннее состояние. Он принимает начальное значение состояния и возвращает текущее значение состояния и функцию для его обновления. Когда состояние изменяется, компонент будет перерисован с новым значением состояния.

Пример использования useState:
```js
import React, { useState } from 'react';

function Counter() {
const [count, setCount] = useState(0);

const increment = () => {
setCount(count + 1);
};

return (

<div>
<p>Count: {count}</p>
<button onClick={increment}>Increment</button>
</div>
);
}
```
useRef - это хук, который позволяет создавать ссылки на DOM-элементы или на другие значения, которые могут сохраняться между рендерами компонента без вызова перерисовки. Ссылки, созданные с помощью useRef, могут быть изменены без вызова рендера компонента.

Пример использования useRef для доступа к DOM-элементу:
```js
import React, { useRef, useEffect } from 'react';

function FocusableInput() {
const inputRef = useRef(null);

useEffect(() => {
inputRef.current.focus();
}, []);

return <input ref={inputRef} />;
}
```
Разница между useState и useRef:

useState используется для управления состоянием компонента и вызывает перерисовку при изменении состояния. Состояние, управляемое useState, может быть привязано к элементам интерфейса.
useRef используется для сохранения изменяемых значений между рендерами, и изменение значения, хранящегося в useRef, не вызывает перерисовку компонента. Он часто используется для работы с DOM-элементами или для хранения данных, которые не должны вызывать перерисовку.
Важно отметить, что хотя useRef также может использоваться для доступа к DOM-элементам, лучше всего использовать ref напрямую в JSX при работе с элементами. useRef ценен в случаях, когда вам нужно сохранить изменяемое значение, и это значение не обязательно должно влиять на рендеринг компонента.

# 9. В чем разница между useState и useRef? 

Разница между useState и useRef в React заключается в их предназначении и поведении:

useState:

Предназначение: useState - это хук (hook) в React, который используется для добавления состояния в функциональные компоненты. Он позволяет объявлять переменные состояния, которые могут изменяться в процессе работы компонента и вызывают повторный рендеринг компонента при изменении значения.

Сохранение состояния: Каждый вызов useState создает переменную состояния и связанный с ней setter-метод, который позволяет изменять состояние компонента и запускать повторный рендеринг. Обновление состояния вызывает повторный вызов функционального компонента.

Пример использования useState:
```js
import React, { useState } from 'react';

function MyComponent() {
const [count, setCount] = useState(0);

const handleIncrement = () => {
setCount(count + 1);
};

return (

<div>
<p>Счетчик: {count}</p>
<button onClick={handleIncrement}>Увеличить счетчик</button>
</div>
);
}
```
useRef:

Предназначение: useRef - это хук (hook) в React, который используется для получения доступа к DOM-элементам или для сохранения переменных, которые не требуют повторного рендеринга компонента при их изменении.

Сохранение данных: Каждый вызов useRef создает объект с полем current, в котором может храниться любое значение. Значение useRef сохраняется между рендерами компонента и изменения его значения не вызывают повторный рендеринг.

Пример использования useRef:
```js
import React, { useRef, useEffect } from 'react';

function MyComponent() {
const inputRef = useRef(null);

useEffect(() => {
// Фокусируемся на поле ввода при монтировании компонента
inputRef.current.focus();
}, []);

return (

<div>
<input ref={inputRef} type="text" />
</div>
);
}
```
Итак, основная разница между useState и useRef состоит в их предназначении: useState используется для управления состоянием компонента и вызывает повторный рендеринг, а useRef используется для хранения данных, которые не требуют повторного рендеринга компонента.

# 10. Чем отличается хранение состояния в useState и в useRef? 

В React компоненте useState и useReducer могут привести к тому, что ваш компонент будет перерисовываться при каждом вызове функций обновления.

Хук useRef() можно использовать для отслеживания переменных, не вызывая повторного рендеринга. Переменная Ref в React — это изменяемый объект, но его значение сохраняется в React при всех повторных рендерингах. Объект ref имеет единственное свойство current, благодаря чему ref имеет структуру, подобную { current: ReactElementReference}. Часто ref используют для хранения ссылок на DOM элементы, для реализации уникального поведения этих елементов (например получение фокуса).

Уникальный способ применения хука useRef — использовать его для хранения значений вместо ссылок DOM. Эти значения могут быть либо состоянием, которое не нужно менять слишком часто, либо состоянием, которое должно меняться как можно чаще, но не должно вызывать полного перерисовки компонента.

В React существует два механизма рендеринга: shallow и deep. Поверхностный рендеринг (shallow) затрагивает только компонент, но не его дочерние элементы, в то время как **глубокий рендеринг (deep) **затрагивает сам компонент и все его дочерние элементы.

После обновления значение useRef обновляется, но дочерние компоненты не обновляют свой пользовательский интерфейс, поскольку они не перерисовываются. Это поверхностный рендеринг, и именно он реализован для хука useRef.

Глубокий рендеринг используется при обновлении состояния с помощью хука useState.

# 11. Расскажите о хуке useReducer. Какие функции он выполняет? 

useReducer - это хук в React, который позволяет управлять состоянием компонента. Он принимает два аргумента: функцию-редьюсер и начальное состояние компонента. Функция-редьюсер принимает текущее состояние компонента и действие, которое нужно выполнить, и возвращает новое состояние компонента.

useReducer позволяет управлять более сложными состояниями, чем простые переменные, и делает код более читаемым и поддерживаемым. Он также позволяет легко добавлять и удалять действия, которые могут быть использованы для изменения состояния компонента.

useReducer также может быть полезен при работе с асинхронными действиями, так как он позволяет управлять состоянием компонента в асинхронном режиме.

Пример использования:
```js
import React, { useReducer } from "react";
const initialState = { count: 0 };
function reducer(state, action) {
switch (action.type) {
case "increment":
return { count: state.count + 1 };
case "decrement":
return { count: state.count - 1 };
default:
throw new Error();
}
}
function Counter() {
const [state, dispatch] = useReducer(reducer, initialState);
const increment = () => {
dispatch({ type: "increment" });
};
const decrement = () => {
dispatch({ type: "decrement" });
};
return (

<div>
<p>Count: {state.count}</p>
<button onClick={increment}>Increment</button>{" "}
<button onClick={decrement}>Decrement</button>
</div>
);
}
```
# 12. Сталкивались ли вы с хуком useLayoutEffect? 

Хук useLayoutEffect похож на useEffect в React, и хотя оба хука позволяют выполнять побочные эффекты в функциональных компонентах, useLayoutEffectони срабатывают синхронно после всех мутаций DOM, но до того, как браузер сможет отобразить эти изменения на экране. Это может быть полезно, когда нужно прочитать информацию о макете из DOM или выполнить действия, требующие синхронных обновлений.

Синтаксис использования useLayoutEffect такой же, как у useEffect:
```js
import React, { useLayoutEffect } from 'react';

function MyComponent() {
useLayoutEffect(() => {
// Your side-effect code here
// This code will run after the component has rendered but before the browser paints the changes on the screen
// It's a good place for DOM measurements or other imperative actions

    return () => {
      // Cleanup code here (optional)
    };

}, []); // Dependency array

// Render your component
return (
// JSX code
);
}
```
Вот несколько важных моментов, которые следует учитывать при использовании useLayoutEffect:

Время: useLayoutEffect запускается синхронно сразу после того, как React выполнил все мутации DOM. Это потенциально может заблокировать отрисовку и сделать приложение менее отзывчивым, если код внутри хука выполняется долго.

Массив зависимостей: как и в случае с useEffect, вы можете указать массив зависимостей в качестве второго аргумента для useLayoutEffect. Он определяет, когда эффект должен работать. Если массив зависимостей пуст ([ ]), эффект запустится только один раз после начального рендеринга. Если вы предоставляете зависимости, эффект будет выполняться при каждом изменении любой из зависимостей.

useLayoutEffect ведет себя аналогично методам жизненного цикла componentDidMount и componentDidUpdate в компонентах класса. Однако из-за его синхронного характера обычно рекомендуется использовать useEffectвместо этого, если только вам не нужно специально взаимодействовать с DOM перед отрисовкой браузера.

Рендеринг на стороне сервера (SSR): Если вы используете рендеринг на стороне сервера, это useLayoutEffectможет привести к некоторым предупреждениям или ошибкам. В этом случае вы можете использовать его useEffectвместо этого, так как он выполняется асинхронно в браузере и не блокирует отрисовку сервера.

useLayoutEffect необходимо использовать с осторожностью и только тогда, когда действительно нужно выполнять связанные с макетом или синхронные задачи. В большинстве случаев useEffect является предпочтительным вариантом.

# 13. Чем отличается useEffect от useLayoutEffect? 

useEffect и useLayoutEffect - это два хука, которые используются в React для выполнения побочных эффектов в функциональных компонентах. Они отличаются друг от друга по тому, когда они выполняются.

useEffect выполняется после того, как компонент был отрисован в DOM и после каждого обновления. Он используется для выполнения побочных эффектов, таких как загрузка данных из API, подписка на события или изменение DOM. useEffect принимает два аргумента: функцию эффекта и массив зависимостей. Функция эффекта выполняет побочный эффект, а массив зависимостей определяет, когда эффект должен быть выполнен. Если массив зависимостей пустой, то эффект будет выполнен только один раз после первого рендеринга компонента.

useLayoutEffect выполняется сразу после того, как браузер получил информацию о размерах и положении элементов на странице. Он используется для выполнения побочных эффектов, которые зависят от размеров и положения элементов на странице, таких как анимация или изменение стилей. useLayoutEffect принимает те же два аргумента, что и useEffect , но он выполняется сразу после того, как браузер получил информацию о размерах и положении элементов на странице.

Обратите внимание, что useEffect может вызывать бесконечный цикл, если зависимости не определены правильно. Поэтому вместо useEffect следует использовать useLayoutEffect , если побочный эффект зависит от размеров и положения элементов на странице.

Таким образом, useEffect используется для выполнения побочных эффектов после того, как компонент был отрисован в DOM и после каждого обновления, а useLayoutEffect используется для выполнения побочных эффектов сразу после того, как браузер получил информацию о размерах и положении элементов на странице.

# 14. Как воспроизвести функциональность классовых методов componentDidUpdate и componentDidMount в функциональных компонентах? 

componentDidUpdate: Код метода componentDidUpdate выполняется, когда компонент обновляется и перерисовывается. Для аналогичной функциональности можно использовать хук useEffect с не пустым массивом зависимостей. Это позволит выполнить эффект после монтирования компонента и после каждого обновления.
```js
import React, { useEffect } from 'react';

function FunctionalComponent() {
useEffect(() => {
// Здесь размещается код для выполнения побочного эффекта
// ...

// Функция очистки, выполняющаяся перед размонтированием компонента
return () => {
// Здесь размещается код для очистки побочного эффекта
// ...
};
}, [dependency1, dependency2]);
}
```
componentDidMount: Метод componentDidMount вызывается после того, как компонент был добавлен в DOM. В функциональных компонентах аналогичную функциональность можно достичь с помощью хука useEffect с пустым массивом зависимостей. Этот хук будет выполнять код эффекта после монтирования компонента.
```js
import React, { useEffect } from 'react';

function FunctionalComponent() {
useEffect(() => {
// Код, который будет выполнен после монтирования компонента
// Этот код аналогичен componentDidMount
}, []);

return (
// JSX вашего компонента
);
}
```
# 15. Что такое кастомный хук? 

    Кастомный хук - это функция, которая выносит логику компонента в отдельную единицу для повторного использования.

Основное отличие кастомных хуков от обычных функций заключается в использовании внутри них стандартных хуков React, таких как useState, useEffect и т.д. Кастомные хуки, подобно стандартным, предназначены для использования внутри функциональных компонентов.

Вот пример хука useInput, который содержит логику обновления значения value в теге input. Этот хук позволяет вынести логику в отдельную функцию, что делает код чище и понятнее, и не загромождает его повторениями:
```js
import React, { useState } from 'react';

function useInput(initialValue) {
const [value, setValue] = useState(initialValue);
function handleChange(e) {
setValue(e.target.value);
}
return [value, handleChange];
}

export default useInput;
```
При написании кастомных хуков нужно придерживаться следующих правил:

Кастомный хук должен начинаться с префикса use;
Кастомные хуки должны избегать прямой работы с DOM элементами. Вместо этого, используйте useRef для управления элементами DOM;
Кастомные хуки должны вызываться только на верхнем уровне функционального компонента, как и стандартные хуки;
Возвращайте массив или объект из кастомных хуков, как и в стандартных хуках. Если возвращается одно значение, массив или объект необязательны. Если возвращается два значения, массив будет достаточным. Если возвращается больше двух значений, лучше использовать объект.

# 16. В React 18 появлось несколько новых хуков, какие? 

В новом React 18 появилось несколько новых хуков:

useSyncExternalStore: Этот хук позволяет синхронизировать данные между клиентом и сервером. Он может быть полезен, если вы хотите обновлять данные на странице без перезагрузки.

useInsertionEffect: Этот хук позволяет выполнить эффект после вставки элемента в DOM. Он может быть полезен, если вы хотите выполнить какой-то код после вставки элемента в DOM.

useDeferredValue : Этот хук позволяет отложить обновление значения до тех пор, пока не будет готово клиентское приложение. Он может быть полезен, если вы хотите ускорить загрузку страницы, не дожидаясь завершения загрузки всех данных.

useOpaqueIdentifier : Этот хук позволяет создавать неопознанные идентификаторы, которые могут быть использованы для дедупликации элементов. Он может быть полезен, если вы хотите создавать компоненты, которые могут быть использованы несколько раз на странице.

useTransition : Этот хук позволяет управлять анимациями в компонентах React. Он может быть полезен, если вы хотите создавать анимации, которые не будут блокировать рендеринг страницы.
