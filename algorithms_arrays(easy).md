## ЗАДАЧА 1: Две суммы
Дан массив целых чисел nums и целое число target. Вернуть индексы двух чисел таких, что их сумма равна target.

Вы можете предположить, что у каждого ввода ровно одно решение, и вы не можете использовать один элемент дважды.

Вы можете вернуть ответ в любом порядке.

Примеры
Пример 1:
```js
**Вход:** nums = [2,7,11,15], target = 9
**Вывод:** [0,1]
**Объяснение:** Поскольку nums[0] + nums[1] == 9, мы возвращаем [0, 1].
```
Пример 2:
```js
**Вход:** nums = [3,2,4], target = 6
**Вывод:** [1,2]
```
Пример 3:
```js
**Вход:** nums = [3,3], target = 6
**Вывод:** [0,1]
```
Ограничения
```js
2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
```
Существует только один правильный ответ.
Фоллоу-ап
Можете ли вы разработать алгоритм с временной сложностью O(n2)?

# РЕШЕНИЕ

Алгоритм 1
Алгоритм

Подход грубой силы прост. Пройдитесь по каждому элементу xxx и найдите значение, которое равно разности между целью и xxx (target−xtarget - xtarget−x).

Реализация

```js
function twoSum(nums, target) {
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            if (nums[j] === target - nums[i]) {
                return [i, j];
            }
        }
    }
    return null;
}
```
Анализ сложности

Временная сложность: O(n2).
Для каждого элемента мы пытаемся найти его комлемент, перебирая остальной массив, что занимает O(n) времени. Следовательно, временная сложность равна O(n2).

Пространственная сложность: O(1).
Затрачиваемое пространство не зависит от размера входного массива, поэтому используется только константное пространство.

Алгоритм 2
Оказывается, мы можем сделать это за один проход. Во время итерации и вставки элементов в хеш-таблицу мы также проверяем, существует ли уже комплимент текущего элемента в хеш-таблице. Если он существует, мы нашли решение и сразу возвращаем индексы.

Реализация

```js
function twoSum(nums, target) {
    let map = new Map();
    for (let i = 0; i < nums.length; i++) {
        let complement = target - nums[i];
        if (map.has(complement)) {
            return [map.get(complement), i];
        }
        map.set(nums[i], i);
    }
    return null;
}
```
Анализ сложности

Временная сложность: O(n).
Мы проходимся по списку, содержащему n элементов, только один раз. Каждая проверка в таблице занимает только O(1) времени.

Пространственная сложность: O(n).
Дополнительное пространство, необходимое, зависит от количества элементов, хранящихся в хеш-таблице, которая хранит не более n элементов.

## ЗАДАЧА 2: Максимальная прибыль от транзакций с акциями

У вас есть массив prices, где prices[i] - это цена данной акции в i-й день.

Вы хотите максимизировать свою прибыль, выбирая один день для покупки одной акции и выбирая другой день в будущем для ее продажи.

Верните максимальную прибыль, которую вы можете получить от этой транзакции. Если вы не можете получить никакую прибыль, вернитесь 0.

Пример 1:

```js
**Ввод:** prices = [7,1,5,3,6,4]
**Вывод:** 5
**Пояснение:** Купите во второй день (цена = 1) и продайте в пятый день (цена = 6), прибыль = 6-1 = 5.
```
Обратите внимание, что покупка во второй день и продажа в первый день не разрешается, потому что вы должны купить до продажи.
Пример 2:
```js
**Ввод:** prices = [7,6,4,3,1]
**Вывод:** 0
**Пояснение:** В этом случае не совершается никаких транзакций, и максимальная прибыль = 0.
```
Ограничения:
```js
1 <= prices.length <= 105
0 <= prices[i] <= 104
```
# РЕШЕНИЕ
Алгоритм 1
Данная задача связана с нахождением максимальной прибыли от покупки и продажи акций.

Основная идея решения заключается в том, чтобы находить минимальную цену акции для покупки и максимальную цену акции для продажи.

Мы будем проходить по массиву цен акций и обновлять минимальную цену акции, если текущая цена меньше минимальной. Далее мы будем вычислять прибыль, которую можно получить на текущем дне, путем вычитания минимальной цены акции из текущей цены акции. Если данная прибыль больше максимальной прибыли, мы обновляем максимальную прибыль.

В конце прохода по массиву, мы получим максимальную прибыль, которую можно получить от этой транзакции. Если все цены акций в массиве убывают, то максимальная прибыль будет равна 0.

Таким образом, можно реализовать данное решение, проходя по массиву цен акций один раз и обновляя минимальную цену и максимальную прибыль на каждом шаге.

Сложность данного алгоритма составляет O(n), где n - количество цен акций.

```js
function maxProfit(prices) {
    let maxProfit = 0;
    let minPrice = prices[0];
    
    for (let i = 1; i < prices.length; i++) {
        if (prices[i] < minPrice) {
            minPrice = prices[i];
        } else {
            let profit = prices[i] - minPrice;
            if (profit > maxProfit) {
                maxProfit = profit;
            }
        }
    }
    
    return maxProfit;
}
```

## ЗАДАЧА 3: Поиск единственного числа в массиве, где каждый элемент повторяется дважды
Учитывая непустой массив целых чисел nums, каждый элемент встречается дважды, кроме одного. Найдите это единственное число.

Вы должны реализовать решение с линейной временной сложностью и использовать только постоянное дополнительное пространство.

Пример 1:
```js
**Input:** nums = [2,2,1]
**Output:** 1
```
Пример 2:
```js
**Input:** nums = [4,1,2,1,2]
**Output:** 4
```
Пример 3:
```js
**Input:** nums = [1]
**Output:** 1
```
Ограничения:
```js
1 <= nums.length <= 3 * 104
-3 * 104 <= nums[i] <= 3 * 104
// Каждый элемент в массиве встречается дважды, кроме одного элемента, который встречается только один раз.
```
# РЕШЕНИЕ

Алгоритм 1
Для решения этой задачи с линейной временной сложностью и использованием только постоянного дополнительного пространства, можно воспользоваться операцией побитового исключающего ИЛИ (^) над всеми элементами массива.

Так как каждый элемент, кроме одного, встречается дважды, при применении операции XOR ко всем элементам массива, парные элементы будут уничтожены, и останется только значение уникального элемента.

Пример:

Дан массив [4,1,2,1,2].

Применим операцию XOR ко всем элементам массива:

4 ^ 1 ^ 2 ^ 1 ^ 2 = 4 ^ (1 ^ 1) ^ (2 ^ 2) = 4 ^ 0 ^ 0 = 4
Таким образом, найденное значение будет равно 4, так как 4 - это единственный элемент, который не имеет пары.

Временная сложность этого решения составляет O(n), где n - это длина массива, так как операция XOR выполняется один раз над всеми элементами массива. Дополнительное пространство, используемое этим решением, постоянно и не зависит от размера входных данных.
```js
function findSingleNumber(nums) {
  let result = 0;
  for (let num of nums) {
    result ^= num;
  }
  return result;
}
```
## ЗАДАЧА 4: Элемент большинства в массиве
Учитывая массив nums размером n, верните элемент большинства.

Элемент большинства - это элемент, который появляется более ⌊n / 2⌋ раз. Вы можете предположить, что элемент большинства всегда существует в массиве.

Пример 1:
```js
**Вход:** nums = [3,2,3]
**Выход:** 3
```
Пример 2:
```js
**Вход:** nums = [2,2,1,1,1,2,2]
**Выход:** 2
```
Ограничения:
```js
n == длина массива nums
1 <= n <= 5 * 104
-109 <= nums[i] <= 109
// Дополнительный вопрос: Можете ли вы решить эту проблему за линейное время и использовать O(1) памяти?
```
# РЕШЕНИЕ

Алгоритм 1
Для решения данной задачи нам нужно найти элемент массива, который встречается больше половины раз.

Одним из способов решения является использование алгоритма "голосования" (Boyer-Moore Voting Algorithm).

Алгоритм работает следующим образом:

Инициализируем переменную majority и счетчик count равными 0.
Проходим по каждому элементу массива.
Если счетчик count равен 0, то текущий элемент становится majority и увеличиваем count на 1.
Если текущий элемент равен majority, то увеличиваем count на 1.
Если текущий элемент не равен majority, то уменьшаем count на 1.
После прохода по всем элементам, majority будет содержать искомый элемент.
Данный алгоритм основывается на том факте, что элемент большинства всегда будет иметь счетчик count больше 0, так как он встречается более половины раз. При этом алгоритм работает за линейное время и использует постоянную дополнительную память.

Таким образом, мы можем решить данную задачу, используя алгоритм "голосования".
```js
/**
 * Функция для нахождения элемента большинства
 * @param {number[]} nums - массив чисел
 * @return {number} - элемент большинства
 */
function majorityElement(nums) {
  let count = 0;
  let candidate;

  for (let i = 0; i < nums.length; i++) {
    // Если счетчик равен 0, то текущий элемент становится кандидатом на элемент большинства
    if (count === 0) {
      candidate = nums[i];
    }
    
    // Если текущий элемент равен кандидату, то увеличиваем счетчик
    // Иначе уменьшаем счетчик
    count += (nums[i] === candidate) ? 1 : -1;
  }
  
  return candidate;
}
```

## ЗАДАЧА 5: Проверка наличия повторяющихся значений в массиве
Дан массив целых чисел nums. Верните true, если в массиве есть хотя бы одно повторяющееся значение, и верните false, если все элементы различны.

Пример 1:
```js
**Input:** nums = [1,2,3,1]
**Output:** true
```
Пример 2:
```js
**Input:** nums = [1,2,3,4]
**Output:** false
```
Пример 3:
```js
**Input:** nums = [1,1,1,3,3,4,3,2,4,2]
**Output:** true
```
Ограничения:
```js
1 <= nums.length <= 105
-109 <= nums[i] <= 109
```
# РЕШЕНИЕ
Алгоритм 1
Нужно проверить, есть ли в массиве хотя бы два одинаковых элемента. Для этого можно создать множество Set и проходить по массиву, добавляя каждый элемент в множество. Если при добавлении элемента в множество возвращается false, значит такой элемент уже был добавлен ранее и в массиве есть повторяющиеся элементы. В этом случае функция должна вернуть true. Если после прохода по всем элементам множество не содержит повторяющихся элементов, функция должна вернуть false.
```js
function containsDuplicate(nums) {
  const set = new Set(nums); // создаем Set из массива
  return set.size !== nums.length; // сравниваем длину Set с длиной исходного массива
}

```