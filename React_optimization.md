# 1. Оптимизации встроенными инструментами из React

Мемоизация:

React.memo это HOC, поверхностно сравнивает компоненты между отрисовками и если входные параметры (props) не изменились, то не вызывает рендер компонента, то есть мемоизирует компонент.
useMemo возвращает мемоизированное значение.
useCallback возвращает мемоизированный колбэк.
Удаление встроенных функций — это функции, которые определяются и передаются при рендеринге компонентов. Вот пример плохой оптимизации:

```js
import Child from "components/Child";

const Parent = () => (
  <Child
    onClick={() => {
      console.log("Случился клик!");
    }}
  />
);

export default Parent;
```

В нашем коде имеется встроенная функция. С такими функциями сопряжено 2 главных проблемы:

Они запускают повторный рендеринг компонента даже в случае, когда пропы остались прежними.
Это, в свою очередь, увеличивает расход памяти.
Решение: выносим встроенные функции из рендеринга компонента.

```js
import Child from "components/Child";

const Parent = () => {
  const handleClick = () => {
    console.log("Случился клик!");
  };

  return <Child onClick={handleClick} />;
};
```

Условный рендеринг позволяет также оптимизировать код и улучшить производительность приложения. В примере ниже пример использования условного рендеринга в модальном окне:

```js
import { useState } from 'react'
import { Modal, Button } from 'someCSSFramework'

const Modal = ({ isOpen, title, body, onClose }) => {
const [open, setOpen] = useState(isOpen || false)

const handleClick =
typeof onClose === 'function'
? onClose
: () => { setOpen(false) }

// условный рендеринг
if (!open) return null

return (
<Modal show={open}>
<Button onClick={handleClick}>x<Button>
<Modal.Header>{title}</Modal.Header>
<Modal.Body>{body}</Modal.Body>
</Modal>
)
}
```

# 2. Если мы применяем LazyLoading какие изменения появляются в сборке

Применение LazyLoading может привести к изменениям в сборке, если оно не было оптимизировано для этого подхода. LazyLoading - это подход к загрузке модулей, при котором модули загружаются только при необходимости, а не сразу после загрузки всего приложения.

Если мы применяем LazyLoading, то модули могут быть загружены только при необходимости, что может привести к увеличению времени загрузки приложения. Кроме того, если мы не оптимизируем сборку для LazyLoading, то это может привести к увеличению размера сборки и ухудшению производительности приложения.

Для оптимизации сборки для LazyLoading можно использовать различные инструменты и технологии, такие как Webpack, Rollup, Parcel и т.д. Эти инструменты позволяют оптимизировать сборку, удалять неиспользуемый код, минифицировать и оптимизировать код и т.д.

Например, в Webpack можно использовать плагин webpack-bundle-analyzer , который позволяет анализировать размеры и количество модулей в сборке и оптимизировать их для LazyLoading. Кроме того, можно использовать другие плагины и инструменты, такие как tree-shaking , code-splitting и т.д., чтобы улучшить производительность и оптимизировать сборку.

Таким образом, применение LazyLoading может привести к изменениям в сборке, если оно не было оптимизировано для этого подхода. Для оптимизации сборки можно использовать различные инструменты и технологии, такие как Webpack, Rollup, Parcel и т.д.

# 3. Можно ли обернуть все переменные и функции в useMemo useCallback? В чем минусы

Да, можно обернуть все переменные и функции в useMemo и useCallback , чтобы избежать ненужных перерисовок компонента и повысить производительность.

useMemo - это хук, который позволяет кэшировать результат выполнения функции и использовать его повторно при необходимости, вместо повторного выполнения функции заново. Это может улучшить производительность компонента, так как результаты выполнения функции будут кэшироваться и использоваться повторно, а не перерисовываться заново при изменении входных данных.

useCallback - это хук, который позволяет кэшировать функцию и использовать ее повторно при необходимости, вместо повторного создания функции заново. Это может улучшить производительность компонента, так как функция будет кэшироваться и использоваться повторно, а не перерисовываться заново при изменении входных данных.

Однако, необходимо учитывать, что использование useMemo и useCallback может привести к утечкам памяти, если не используется правильно. Например, если функция, переданная в useCallback , зависит от переменной, которая изменится при каждом рендере компонента, то useCallback будет создавать новую функцию при каждом рендере, что может привести к утечкам памяти.

Не стоит использовать useMemo и useCallback если операция не затратна по времени и не нагружает память. Например, большинство встроенных методов JavaScript оптимизированы, и нет необходимости запоминать возвращаемое ими значение при каждом вызове. Вызов хуков сам по себе создает нагрузку, и их применение может не окупиться.

Также, необходимо учитывать, что использование useMemo и useCallback может усложнить код и затруднить его понимание и поддержку. Поэтому, перед использованием useMemo и useCallback , необходимо убедиться, что они действительно необходимы и не приведут к ухудшению производительности и качества кода.

# 4. Каким образом можно достичь повторного использования общей логики между двумя компонентами в React?

В React существует несколько способов достижения повторного использования общей логики между двумя компонентами:

Вынос логики в отдельный кастомный хук (Custom Hook): Вы можете создать свой собственный хук, содержащий общую логику, и затем использовать этот хук в любых компонентах, где требуется эта логика. Кастомные хуки позволяют абстрагировать логику от компонентов и обеспечивают повторное использование.

Пример:

```js
// useCommonLogic.js
import { useState } from "react";

function useCommonLogic() {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1);
  };

  return { count, increment };
}

export default useCommonLogic;
```

```js
// ComponentA.js
import React from "react";
import useCommonLogic from "./useCommonLogic";

function ComponentA() {
  const { count, increment } = useCommonLogic();

  return (
    <div>
      <p>Component A Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

```js
// ComponentB.js
import React from "react";
import useCommonLogic from "./useCommonLogic";

function ComponentB() {
  const { count, increment } = useCommonLogic();

  return (
    <div>
      <p>Component B Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

Композиция компонентов: Создайте общий компонент, который содержит общую логику, а затем используйте его в других компонентах, чтобы получить доступ к этой логике через пропсы.

Пример:

```js
// CommonComponent.js
import React, { useState } from "react";

function CommonComponent() {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1);
  };

  return (
    <div>
      <p>Common Component Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}

export default CommonComponent;
```

```js
// ComponentA.js
import React from "react";
import CommonComponent from "./CommonComponent";

function ComponentA() {
  return (
    <div>
      <CommonComponent />
    </div>
  );
}
```

```js
// ComponentB.js
import React from "react";
import CommonComponent from "./CommonComponent";

function ComponentB() {
  return (
    <div>
      <CommonComponent />
    </div>
  );
}
```

Оба подхода позволяют достигнуть повторного использования общей логики между компонентами в React. Выбор подхода зависит от конкретных требований вашего проекта и организации кода.

Использование Higher-Order Components (HOC)
HOC - это функция, которая принимает компонент и возвращает новый компонент с дополнительной логикой. Можно создать HOC, который инкапсулирует общую логику и передавать различные компоненты для повторного использования этой логики. Ниже приведен пример HOC для добавления общей логики отображения заголовка:

```js
function withHeader(Component) {
  return function WithHeader(props) {
    return (
      <>
        <h1>Common Header</h1>
        <Component {...props} />
      </>
    );
  };
}

function ComponentA() {
  return <div>Component A</div>;
}

const ComponentWithHeaderA = withHeader(ComponentA);

function ComponentB() {
  return <div>Component B</div>;
}

const ComponentWithHeaderB = withHeader(ComponentB);

// Использование
ReactDOM.render(
  <>
    <ComponentWithHeaderA />
    <ComponentWithHeaderB />
  </>,
  document.getElementById("root")
);
```

Использование Render Props
Render Props - это техника, при которой компонент принимает функцию в качестве свойства (props) и использует эту функцию для возврата содержимого, которое будет отображено. Можно передавать различные функции для повторного использования общей логики. Ниже приведен пример использования Render Props для отображения текущей даты и времени:

```js
function DateTime(props) {
  const date = new Date();
  return props.render(date);
}

function ComponentA() {
  return (
    <DateTime
      render={(date) => (
        <div>Component A - Current Date: {date.toLocaleString()}</div>
      )}
    />
  );
}

function ComponentB() {
  return (
    <DateTime
      render={(date) => (
        <div>Component B - Current Date: {date.toLocaleString()}</div>
      )}
    />
  );
}

// Использование
ReactDOM.render(
  <>
    <ComponentA />
    <ComponentB />
  </>,
  document.getElementById("root")
);
```

Композиция компонентов
React предоставляет мощный механизм композиции компонентов, который позволяет создавать более сложные компоненты из простых и повторно использовать их. Это достигается путем создания компонентов, которые содержат или оборачивают другие компоненты, чтобы объединить их функциональность. Такой подход позволяет создавать модульный код, где каждый компонент отвечает только за свою собственную ответственность.

Higher-Order Components (HOC)
HOC - это функция, которая принимает компонент и возвращает новый компонент с дополнительной логикой. Это позволяет выделить общую логику из компонентов и повторно использовать ее между различными компонентами. HOC может добавлять дополнительные свойства, оборачивать компоненты в другие компоненты или изменять их поведение. HOC являются мощным инструментом для повторного использования логики и улучшения расширяемости компонентов.

Render Props
Render Props - это паттерн, который позволяет компонентам передавать функцию через свойство (props), которая будет использоваться для рендеринга содержимого. Это позволяет изолировать общую логику в отдельном компоненте и передавать различные функции в компоненты для повторного использования этой логики. В результате, компоненты становятся более гибкими и могут адаптироваться к разным потребностям и сценариям использования.

React Hooks
Введение React Hooks в React 16.8 добавило еще больше возможностей для повторного использования логики между компонентами. Хуки, такие как useEffect, useMemo, useCallback, позволяют изолировать и повторно использовать определенные фрагменты логики в функциональных компонентах. Например, useEffect позволяет выполнять определенные действия при изменении определенных зависимостей, что может быть полезно для общей логики, связанной с эффектами или подписками

Библиотеки и фреймворки для повторного использования
Существуют различные библиотеки и фреймворки, которые помогают в повторном использовании общей логики в React. Например, Redux предоставляет возможности для управления глобальным состоянием приложения, что позволяет легко использовать общую логику между различными компонентами. Библиотеки, такие как React Router, предоставляют средства для управления маршрутизацией и повторного использования компонентов, связанных с навигацией.

# 5. Как увеличить производительность?

Существует несколько способов увеличить производительность сайта:

Оптимизация кода: убедитесь, что ваш код оптимизирован для быстрой загрузки страницы. Это может включать в себя уменьшение размера файлов, улучшение кэширования, оптимизацию изображений и т.д.

Использование серверов с более высокой производительностью: выберите серверы с более быстрым оборудованием и высокой производительностью, чтобы ускорить загрузку страницы.

Использование кэширования: кэширование может помочь ускорить загрузку страницы, сохраняя копии страниц на сервере и загружая их при следующем запросе.

Оптимизация загрузки ресурсов: используйте различные методы оптимизации загрузки ресурсов, такие как асинхронная загрузка скриптов и стилей, минификация и сжатие кода.

Использование CDN: CDN может помочь ускорить загрузку страницы, распределяя содержимое с ближайшими серверами, что уменьшает время загрузки и улучшает производительность.

Оптимизация SEO: убедитесь, что ваш сайт оптимизирован для поисковых систем, используя правильные метатеги, улучшая качество контента и уменьшая количество контента, который не интересен пользователям.

Использование аналитики: аналитика может помочь выявить проблемы производительности и оптимизировать ваш сайт для ускорения загрузки страницы.

В целом, увеличение производительности сайта требует тщательного анализа и оптимизации, чтобы достичь наилучшего качества и быстрой загрузки страницы.

# 6. Перфоменс трюки в React

В React есть множество трюков, которые могут быть полезными в различных ситуациях. Некоторые из них:

Использование композиционного подхода: композиция компонентов позволяет создавать более сложные компоненты, которые могут быть повторно использованы в разных частях приложения.

Использование хуков: хуки позволяют добавлять дополнительную логику в компоненты, такую как обработка событий, получение данных из API и т.д.

Использование контекста: контекст позволяет передавать данные между компонентами без необходимости передачи их через пропсы.

Использование рефов: рефы позволяют изменять состояние компонентов без необходимости передачи их через пропсы.

Использование мемоизации: мемоизация позволяет кэшировать результаты вычислений, чтобы избежать ненужных вычислений при каждом рендеринге компонента.

Использование асинхронности: асинхронность позволяет выполнять длительные операции в фоновом режиме, не блокируя основной поток выполнения приложения.

Использование состояния: состояние позволяет хранить данные в компонентах и обновлять их при изменении.

Использование пропсов: пропсы позволяют передавать данные от родительского компонента к дочерним компонентам.

Использование рефакторинга: рефакторинг позволяет улучшить структуру и производительность кода, устраняя дублирование кода и упрощая разработку.

Использование тестирования: тестирование позволяет обнаруживать ошибки и проблемы в коде, улучшая качество приложения и предотвращая возможные проблемы в будущем.

# 7. Что такое React.Lazy?

React.Lazy() - это функция высшего порядка в React, которая позволяет отложить загрузку компонента до тех пор, пока он не понадобится. Это может улучшить производительность приложения, так как компоненты, которые не нужны на данный момент, не загружаются.

React.Lazy() принимает функцию, которая возвращает компонент, который нужно загрузить. Например:

```js
import React, { lazy, Suspense } from "react";

const LazyComponent = lazy(() => import("./LazyComponent"));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}

export default App;
```

В этом примере компонент LazyComponent будет загружаться только при первом использовании в приложении. Если компонент не используется, то загрузка не произойдет.

# 8. Если вы выполняете маппинг коллекции без указания явного ключа, какой ключ будет использоваться по умолчанию? Какой ключ будет использоваться для каждого компонента?

По умолчанию в React используется ключ \_id , который автоматически генерируется при добавлении нового элемента в коллекцию. Ключ \_id является уникальным идентификатором элемента в коллекции.

Ключ для каждого компонента может быть определен явно, используя атрибут key . Если ключ не указан явно, React будет использовать ключ по умолчанию, который может быть неуникальным или нестабильным.

Например, если вы хотите отобразить список элементов в компоненте List , вы можете использовать ключ \_id для каждого элемента:

```js
function List({ items }) {
return (

<ul>
{items.map(item => (
<li key={item._id}>{item.name}</li>
))}
</ul>
);
}
Если вы хотите отобразить список элементов в компоненте List с использованием компонента Item , вы можете использовать ключ item.\_id для каждого элемента:

function List({ items }) {
return (

<ul>
{items.map(item => (
<Item key={item._id} item={item} />
))}
</ul>
);
}

function Item({ item }) {
return (

<li>{item.name}</li>
);
}
```

Обратите внимание, что ключ должен быть уникальным для каждого элемента в коллекции, чтобы React мог эффективно обновлять и удалять элементы при изменении коллекции.

# 9. Зачем нужна функция lazy в React?

Функция lazy в React используется для ленивой загрузки компонентов. Ленивая загрузка позволяет отложить загрузку компонентов до тех пор, пока они не понадобятся для отображения на странице. Это особенно полезно для компонентов, которые редко используются или требуют больших ресурсов.

Когда вы используете функцию lazy, компонент будет загружен только тогда, когда он станет активным, например, когда пользователь проскроллирует страницу или выполнит какое-либо другое действие, приводящее к отображению этого компонента.

Преимущества использования lazy:

Улучшение производительности: Ленивая загрузка позволяет снизить начальное время загрузки приложения, поскольку компоненты, которые не нужны на начальном этапе, не будут загружены сразу.

Оптимизация ресурсов: Компоненты, которые редко используются или требуют больших ресурсов, не будут загружаться, пока не станут необходимы.

Пример использования lazy:

```js
import React, { lazy, Suspense } from "react";

// Импортируем компонент с помощью lazy
const MyLazyComponent = lazy(() => import("./MyLazyComponent"));

function App() {
  return (
    <div>
      {
        /_ Оборачиваем компонент в Suspense, чтобы обработать пока компонент загружается _/
      }
      <Suspense fallback={<div>Loading...</div>}>
        <MyLazyComponent />
      </Suspense>
    </div>
  );
}
```

Здесь MyLazyComponent будет загружаться только при монтировании компонента App и его отображении на странице. Пока компонент загружается, будет показан компонент загрузки (fallback), определенный в Suspense.
