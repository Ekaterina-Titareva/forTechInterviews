<!-- ЗАДАЧА 1: Подсчет гласных -->

Вы должны реализовать функцию countVowels(str), которая принимает на вход строку и возвращает количество гласных букв в этой строке. Гласными считаются буквы "a", "e", "i", "o" и "u" (регистронезависимо).

Пример
countVowels("hello"); // Ожидаемый результат: 2 (e, o)
countVowels("world"); // Ожидаемый результат: 1 (o)
countVowels("apple"); // Ожидаемый результат: 2 (a, e)
Алгоритм
Создайте функцию countVowels(str).

Создайте строку vowels, содержащую все гласные буквы (как в нижнем, так и в верхнем регистре): "aeiouAEIOU".

Инициализируйте переменную count для хранения количества гласных, начальное значение которой равно 0.

Пройдитесь по каждому символу char во входной строке str:

Проверьте, содержится ли символ char в строке vowels с помощью метода includes().
Если символ является гласной, увеличьте значение переменной count на 1.
Верните значение переменной count как результат выполнения функции.

Вот реализация алгоритма на JavaScript:

function countVowels(str) {
const vowels = "aeiouAEIOU";
let count = 0;

    for (const char of str) {
        if (vowels.includes(char)) {
            count++;
        }
    }

    return count;

}
Этот алгоритм перебирает символы во входной строке, проверяет, является ли символ гласной, и увеличивает счетчик, если это так.

<!-- ЗАДАЧА 2: Сумма уникальных элементов -->

Вы должны реализовать функцию sumUniqueElements(arr), которая принимает на вход массив целых чисел и возвращает сумму уникальных элементов этого массива.

Алгоритм
Создайте функцию sumUniqueElements(arr).

Инициализируйте объект numCount (или Map), который будет служить для подсчета количества вхождений каждого элемента массива.

Пройдитесь по каждому элементу num во входном массиве arr:

Для каждого num, увеличьте его счетчик в объекте numCount.
Инициализируйте переменную sum для хранения суммы уникальных элементов.

Пройдитесь по каждой записи в объекте numCount (или по парам ключ-значение в объекте Map):

Если значение счетчика равно 1, добавьте ключ (элемент) к сумме sum.
Верните значение sum как результат выполнения функции.

Вот реализация алгоритма на JavaScript:

function sumUniqueElements(arr) {
const numCount = new Map();

    for (const num of arr) {
        numCount.set(num, (numCount.get(num) || 0) + 1);
    }

    let sum = 0;
    for (const [num, count] of numCount) {
        if (count === 1) {
            sum += num;
        }
    }

    return sum;

}
Этот алгоритм подсчитывает количество вхождений каждого элемента массива и затем суммирует уникальные элементы, у которых счетчик равен 1.

<!-- ЗАДАЧА 3: Палиндромная проверка -->

Описание
Вы должны реализовать функцию isPalindrome(str), которая принимает на вход строку и возвращает true, если строка является палиндромом, и false в противном случае. Палиндром - это строка, которая читается одинаково вперед и назад, игнорируя пробелы, знаки пунктуации и регистр символов.

Пример
isPalindrome("racecar"); // Ожидаемый результат: true
isPalindrome("hello"); // Ожидаемый результат: false
isPalindrome("A man, a plan, a canal, Panama"); // Ожидаемый результат: true
Алгоритм
Создайте функцию isPalindrome(str).

Инициализируйте два указателя: start на начало строки и end на конец строки.

В цикле while сравнивайте символы, на которые указывают start и end, игнорируя не-буквенно-цифровые символы и регистр. Если символы совпадают, увеличивайте start и уменьшайте end. Если символы не совпадают, возвращайте false.

Если цикл успешно завершился (пересеклись указатели), возвращайте true, так как это означает, что строка является палиндромом.

Вот реализация алгоритма на JavaScript без использования встроенных методов:

function isPalindrome(str) {
const cleanedStr = str.toLowerCase().replace(/[^a-z0-9]/g, '');
let start = 0;
let end = cleanedStr.length - 1;

    while (start < end) {
        if (cleanedStr[start] !== cleanedStr[end]) {
            return false;
        }
        start++;
        end--;
    }

    return true;

}
Этот алгоритм осуществляет сравнение символов, двигаясь от начала строки к концу и наоборот, игнорируя не-буквенно-цифровые символы и регистр, и возвращает true, если строка является палиндромом.

<!-- ЗАДАЧА 4: Подсчет уникальных элементов -->

Вы должны реализовать функцию countUniqueElements(arr), которая принимает на вход массив целых чисел и возвращает количество уникальных элементов в этом массиве.

Алгоритм
Создайте пустое множество uniqueElements, которое будет использоваться для хранения уникальных элементов.

Пройдитесь по каждому элементу num во входном массиве arr:

Для каждого num, добавьте его в множество uniqueElements с помощью метода add().
После прохода по всем элементам массива, верните размер множества uniqueElements с помощью свойства size.

Вот реализация алгоритма на JavaScript:

function countUniqueElements(arr) {
const uniqueElements = new Set();
for (const num of arr) {
uniqueElements.add(num);
}
return uniqueElements.size;
}
Этот алгоритм гарантирует, что каждый элемент будет добавлен только один раз в множество uniqueElements, и, следовательно, будет подсчитан только один раз в итоговом результате.

<!-- ЗАДАЧА 5: Сортировка объектов в массиве по свойству -->

Дан массив объектов objects и строковое значение property. Необходимо отсортировать объекты в массиве по указанному свойству.

Реализуйте функцию:

/\*\*

- Сортирует массив объектов по указанному свойству.
- @param {Array} objects - Массив объектов для сортировки.
- @param {string} property - Свойство, по которому нужно выполнить сортировку.
- @return {Array} Отсортированный массив объектов.
  \*/
  function sortObjectsByProperty(objects, property) {
  // Ваш код здесь
  }
  Пример
  const people = [
  { name: 'Alice', age: 30 },
  { name: 'Bob', age: 25 },
  { name: 'Eve', age: 28 }
  ];

const sortedByAge = sortObjectsByProperty(people, 'age');
console.log(sortedByAge);
// Ожидаемый вывод: [
// { name: 'Bob', age: 25 },
// { name: 'Eve', age: 28 },
// { name: 'Alice', age: 30 }
// ]
Алгоритм
Используем метод sort для сортировки массива объектов. Внутри функции сравнения будем обращаться к свойству объекта, указанному в параметре property.

Реализуем функцию сравнения, которая будет передана в метод sort. Функция сравнения будет сравнивать значения свойства property для двух объектов и возвращать результат сравнения.

Внутри функции сравнения, можно использовать операторы сравнения (например, a[property] - b[property] для чисел) или методы сравнения строк (например, a[property].localeCompare(b[property]) для строк).

Вот реализация алгоритма:

function sortObjectsByProperty(objects, property) {
return objects.sort((a, b) => {
if (a[property] < b[property]) {
return -1;
}
if (a[property] > b[property]) {
return 1;
}
return 0;
});
}
Этот алгоритм сравнивает значения указанного свойства для двух объектов и возвращает отрицательное число, если значение в объекте a меньше значения в объекте b, положительное число, если больше, и ноль, если значения равны.

Теперь можно использовать эту функцию для сортировки массивов объектов по указанному свойству, как в предыдущем примере:

const people = [
{ name: 'Alice', age: 30 },
{ name: 'Bob', age: 25 },
{ name: 'Eve', age: 28 }
];

const sortedByAge = sortObjectsByProperty(people, 'age');
console.log(sortedByAge);
// Output: [
// { name: 'Bob', age: 25 },
// { name: 'Eve', age: 28 },
// { name: 'Alice', age: 30 }
// ]
Этот алгоритм будет работать как для числовых свойств, так и для строковых свойств.
